// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vehicle-events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Proto_ChargingBreakClockTimerAction: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case delete // = 0
  case activate // = 1
  case deactivate // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .delete
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .delete
    case 1: self = .activate
    case 2: self = .deactivate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .delete: return 0
    case .activate: return 1
    case .deactivate: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_ChargingBreakClockTimerAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ChargingBreakClockTimerAction] = [
    .delete,
    .activate,
    .deactivate,
  ]
}

#endif  // swift(>=4.2)

enum Proto_ChargeProgram: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case defaultChargeProgram // = 0
  case instantChargeProgram // = 1
  case homeChargeProgram // = 2
  case workChargeProgram // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .defaultChargeProgram
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .defaultChargeProgram
    case 1: self = .instantChargeProgram
    case 2: self = .homeChargeProgram
    case 3: self = .workChargeProgram
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .defaultChargeProgram: return 0
    case .instantChargeProgram: return 1
    case .homeChargeProgram: return 2
    case .workChargeProgram: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_ChargeProgram: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ChargeProgram] = [
    .defaultChargeProgram,
    .instantChargeProgram,
    .homeChargeProgram,
    .workChargeProgram,
  ]
}

#endif  // swift(>=4.2)

/// Same as VehicleAPI.AttributeStatus but with slightly different names. The VehicleAPI.AttributeStatus enum values
/// can't be changed because they are used to automatically parse the vehicleAPI responses. Adding type aliases would
/// confuse the contributions developers, so we added another attribute status enum
enum Proto_AttributeStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Value is set and valid
  case valueValid // = 0

  /// Value has not yet been received from the vehicle (but sensor etc. should be available)
  case valueNotReceived // = 1

  /// Value has been retrieved from vehicle but is invalid (marked as invalid by DaiVB backend)
  case valueInvalid // = 3

  /// Vehicle does not support this attribute (e.g. does not have the sensor etc.)
  case valueNotAvailable // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .valueValid
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .valueValid
    case 1: self = .valueNotReceived
    case 3: self = .valueInvalid
    case 4: self = .valueNotAvailable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .valueValid: return 0
    case .valueNotReceived: return 1
    case .valueInvalid: return 3
    case .valueNotAvailable: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_AttributeStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_AttributeStatus] = [
    .valueValid,
    .valueNotReceived,
    .valueInvalid,
    .valueNotAvailable,
  ]
}

#endif  // swift(>=4.2)

/// Sending direction: App <- BFF <- AppTwin
struct Proto_VEPUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var vin: String = String()

  /// indicates whether this is a full update of VEP-attributes.
  /// All attributes cached in the FE should be erased and completely
  /// replaced by this push.
  var fullUpdate: Bool = false

  /// when was the event emitted? This is the time of the update (unix timestamp in seconds), (deprecated)
  /// not when the attributes where changed. To compare attribute changes, you need to look into each attribute timestamp
  var emitTimestamp: Int64 = 0

  /// when was the event emitted? This is the time of the update (unix timestamp in milliseconds),
  var emitTimestampInMs: Int64 = 0

  /// the attribute changes are a list of changed attributes
  var attributes: Dictionary<String,Proto_VehicleAttributeStatus> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Part of a VEPUpdate
/// Sending direction: App <- BFF <- AppTwin
struct Proto_VehicleAttributeStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// time of the attribute change in the car as unix timestamp in seconds with UTC timezone (deprecated)
  var timestamp: Int64 = 0

  /// time of the attribute change in the car as unix timestamp in milliseconds with UTC timezone
  var timestampInMs: Int64 = 0

  var changed: Bool = false

  var status: Int32 = 0

  /// A list of service ids for which this attribute was sent
  /// this field ist just used backend internally and will always
  /// be empty when sent out to the client.
  var serviceIds: [Int32] = []

  var displayValue: String = String()

  var displayUnit: Proto_VehicleAttributeStatus.OneOf_DisplayUnit? = nil

  var combustionConsumptionUnit: Proto_VehicleAttributeStatus.CombustionConsumptionUnit {
    get {
      if case .combustionConsumptionUnit(let v)? = displayUnit {return v}
      return .unspecifiedCombustionConsumptionUnit
    }
    set {displayUnit = .combustionConsumptionUnit(newValue)}
  }

  var gasConsumptionUnit: Proto_VehicleAttributeStatus.GasConsumptionUnit {
    get {
      if case .gasConsumptionUnit(let v)? = displayUnit {return v}
      return .unspecifiedGasConsumptionUnit
    }
    set {displayUnit = .gasConsumptionUnit(newValue)}
  }

  var electricityConsumptionUnit: Proto_VehicleAttributeStatus.ElectricityConsumptionUnit {
    get {
      if case .electricityConsumptionUnit(let v)? = displayUnit {return v}
      return .unspecifiedElectricityConsumptionUnit
    }
    set {displayUnit = .electricityConsumptionUnit(newValue)}
  }

  /// use speed unit / length unit instead
  var speedDistanceUnit: Proto_VehicleAttributeStatus.SpeedDistanceUnit {
    get {
      if case .speedDistanceUnit(let v)? = displayUnit {return v}
      return .unspecifiedSpeedDistanceUnit
    }
    set {displayUnit = .speedDistanceUnit(newValue)}
  }

  var speedUnit: Proto_VehicleAttributeStatus.SpeedUnit {
    get {
      if case .speedUnit(let v)? = displayUnit {return v}
      return .unspecifiedSpeedUnit
    }
    set {displayUnit = .speedUnit(newValue)}
  }

  var distanceUnit: Proto_VehicleAttributeStatus.DistanceUnit {
    get {
      if case .distanceUnit(let v)? = displayUnit {return v}
      return .unspecifiedDistanceUnit
    }
    set {displayUnit = .distanceUnit(newValue)}
  }

  var temperatureUnit: Proto_VehicleAttributeStatus.TemperatureUnit {
    get {
      if case .temperatureUnit(let v)? = displayUnit {return v}
      return .unspecifiedTemperatureUnit
    }
    set {displayUnit = .temperatureUnit(newValue)}
  }

  var pressureUnit: Proto_VehicleAttributeStatus.PressureUnit {
    get {
      if case .pressureUnit(let v)? = displayUnit {return v}
      return .unspecifiedPressureUnit
    }
    set {displayUnit = .pressureUnit(newValue)}
  }

  var ratioUnit: Proto_VehicleAttributeStatus.RatioUnit {
    get {
      if case .ratioUnit(let v)? = displayUnit {return v}
      return .unspecifiedRatioUnit
    }
    set {displayUnit = .ratioUnit(newValue)}
  }

  var clockHourUnit: Proto_VehicleAttributeStatus.ClockHourUnit {
    get {
      if case .clockHourUnit(let v)? = displayUnit {return v}
      return .unspecifiedClockHourUnit
    }
    set {displayUnit = .clockHourUnit(newValue)}
  }

  var attributeType: Proto_VehicleAttributeStatus.OneOf_AttributeType? = nil

  var intValue: Int64 {
    get {
      if case .intValue(let v)? = attributeType {return v}
      return 0
    }
    set {attributeType = .intValue(newValue)}
  }

  var boolValue: Bool {
    get {
      if case .boolValue(let v)? = attributeType {return v}
      return false
    }
    set {attributeType = .boolValue(newValue)}
  }

  var stringValue: String {
    get {
      if case .stringValue(let v)? = attributeType {return v}
      return String()
    }
    set {attributeType = .stringValue(newValue)}
  }

  var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = attributeType {return v}
      return 0
    }
    set {attributeType = .doubleValue(newValue)}
  }

  var nilValue: Bool {
    get {
      if case .nilValue(let v)? = attributeType {return v}
      return false
    }
    set {attributeType = .nilValue(newValue)}
  }

  var unsupportedValue: String {
    get {
      if case .unsupportedValue(let v)? = attributeType {return v}
      return String()
    }
    set {attributeType = .unsupportedValue(newValue)}
  }

  var temperaturePointsValue: Proto_TemperaturePointsValue {
    get {
      if case .temperaturePointsValue(let v)? = attributeType {return v}
      return Proto_TemperaturePointsValue()
    }
    set {attributeType = .temperaturePointsValue(newValue)}
  }

  var weekdayTariffValue: Proto_WeekdayTariffValue {
    get {
      if case .weekdayTariffValue(let v)? = attributeType {return v}
      return Proto_WeekdayTariffValue()
    }
    set {attributeType = .weekdayTariffValue(newValue)}
  }

  var weekendTariffValue: Proto_WeekendTariffValue {
    get {
      if case .weekendTariffValue(let v)? = attributeType {return v}
      return Proto_WeekendTariffValue()
    }
    set {attributeType = .weekendTariffValue(newValue)}
  }

  var stateOfChargeProfileValue: Proto_StateOfChargeProfileValue {
    get {
      if case .stateOfChargeProfileValue(let v)? = attributeType {return v}
      return Proto_StateOfChargeProfileValue()
    }
    set {attributeType = .stateOfChargeProfileValue(newValue)}
  }

  var weeklySettingsHeadUnitValue: Proto_WeeklySettingsHeadUnitValue {
    get {
      if case .weeklySettingsHeadUnitValue(let v)? = attributeType {return v}
      return Proto_WeeklySettingsHeadUnitValue()
    }
    set {attributeType = .weeklySettingsHeadUnitValue(newValue)}
  }

  var speedAlertConfigurationValue: Proto_SpeedAlertConfigurationValue {
    get {
      if case .speedAlertConfigurationValue(let v)? = attributeType {return v}
      return Proto_SpeedAlertConfigurationValue()
    }
    set {attributeType = .speedAlertConfigurationValue(newValue)}
  }

  var ecoHistogramValue: Proto_EcoHistogramValue {
    get {
      if case .ecoHistogramValue(let v)? = attributeType {return v}
      return Proto_EcoHistogramValue()
    }
    set {attributeType = .ecoHistogramValue(newValue)}
  }

  var weeklyProfileValue: Proto_WeeklyProfileValue {
    get {
      if case .weeklyProfileValue(let v)? = attributeType {return v}
      return Proto_WeeklyProfileValue()
    }
    set {attributeType = .weeklyProfileValue(newValue)}
  }

  var chargeProgramsValue: Proto_ChargeProgramsValue {
    get {
      if case .chargeProgramsValue(let v)? = attributeType {return v}
      return Proto_ChargeProgramsValue()
    }
    set {attributeType = .chargeProgramsValue(newValue)}
  }

  var chargingBreakClockTimer: Proto_ChargingBreakClockTimer {
    get {
      if case .chargingBreakClockTimer(let v)? = attributeType {return v}
      return Proto_ChargingBreakClockTimer()
    }
    set {attributeType = .chargingBreakClockTimer(newValue)}
  }

  var chargingPowerControl: Proto_ChargingPowerControl {
    get {
      if case .chargingPowerControl(let v)? = attributeType {return v}
      return Proto_ChargingPowerControl()
    }
    set {attributeType = .chargingPowerControl(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_DisplayUnit: Equatable {
    case combustionConsumptionUnit(Proto_VehicleAttributeStatus.CombustionConsumptionUnit)
    case gasConsumptionUnit(Proto_VehicleAttributeStatus.GasConsumptionUnit)
    case electricityConsumptionUnit(Proto_VehicleAttributeStatus.ElectricityConsumptionUnit)
    /// use speed unit / length unit instead
    case speedDistanceUnit(Proto_VehicleAttributeStatus.SpeedDistanceUnit)
    case speedUnit(Proto_VehicleAttributeStatus.SpeedUnit)
    case distanceUnit(Proto_VehicleAttributeStatus.DistanceUnit)
    case temperatureUnit(Proto_VehicleAttributeStatus.TemperatureUnit)
    case pressureUnit(Proto_VehicleAttributeStatus.PressureUnit)
    case ratioUnit(Proto_VehicleAttributeStatus.RatioUnit)
    case clockHourUnit(Proto_VehicleAttributeStatus.ClockHourUnit)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_VehicleAttributeStatus.OneOf_DisplayUnit, rhs: Proto_VehicleAttributeStatus.OneOf_DisplayUnit) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.combustionConsumptionUnit, .combustionConsumptionUnit): return {
        guard case .combustionConsumptionUnit(let l) = lhs, case .combustionConsumptionUnit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gasConsumptionUnit, .gasConsumptionUnit): return {
        guard case .gasConsumptionUnit(let l) = lhs, case .gasConsumptionUnit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.electricityConsumptionUnit, .electricityConsumptionUnit): return {
        guard case .electricityConsumptionUnit(let l) = lhs, case .electricityConsumptionUnit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.speedDistanceUnit, .speedDistanceUnit): return {
        guard case .speedDistanceUnit(let l) = lhs, case .speedDistanceUnit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.speedUnit, .speedUnit): return {
        guard case .speedUnit(let l) = lhs, case .speedUnit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.distanceUnit, .distanceUnit): return {
        guard case .distanceUnit(let l) = lhs, case .distanceUnit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.temperatureUnit, .temperatureUnit): return {
        guard case .temperatureUnit(let l) = lhs, case .temperatureUnit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pressureUnit, .pressureUnit): return {
        guard case .pressureUnit(let l) = lhs, case .pressureUnit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ratioUnit, .ratioUnit): return {
        guard case .ratioUnit(let l) = lhs, case .ratioUnit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clockHourUnit, .clockHourUnit): return {
        guard case .clockHourUnit(let l) = lhs, case .clockHourUnit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum OneOf_AttributeType: Equatable {
    case intValue(Int64)
    case boolValue(Bool)
    case stringValue(String)
    case doubleValue(Double)
    case nilValue(Bool)
    case unsupportedValue(String)
    case temperaturePointsValue(Proto_TemperaturePointsValue)
    case weekdayTariffValue(Proto_WeekdayTariffValue)
    case weekendTariffValue(Proto_WeekendTariffValue)
    case stateOfChargeProfileValue(Proto_StateOfChargeProfileValue)
    case weeklySettingsHeadUnitValue(Proto_WeeklySettingsHeadUnitValue)
    case speedAlertConfigurationValue(Proto_SpeedAlertConfigurationValue)
    case ecoHistogramValue(Proto_EcoHistogramValue)
    case weeklyProfileValue(Proto_WeeklyProfileValue)
    case chargeProgramsValue(Proto_ChargeProgramsValue)
    case chargingBreakClockTimer(Proto_ChargingBreakClockTimer)
    case chargingPowerControl(Proto_ChargingPowerControl)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_VehicleAttributeStatus.OneOf_AttributeType, rhs: Proto_VehicleAttributeStatus.OneOf_AttributeType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.intValue, .intValue): return {
        guard case .intValue(let l) = lhs, case .intValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.boolValue, .boolValue): return {
        guard case .boolValue(let l) = lhs, case .boolValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleValue, .doubleValue): return {
        guard case .doubleValue(let l) = lhs, case .doubleValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nilValue, .nilValue): return {
        guard case .nilValue(let l) = lhs, case .nilValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsupportedValue, .unsupportedValue): return {
        guard case .unsupportedValue(let l) = lhs, case .unsupportedValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.temperaturePointsValue, .temperaturePointsValue): return {
        guard case .temperaturePointsValue(let l) = lhs, case .temperaturePointsValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.weekdayTariffValue, .weekdayTariffValue): return {
        guard case .weekdayTariffValue(let l) = lhs, case .weekdayTariffValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.weekendTariffValue, .weekendTariffValue): return {
        guard case .weekendTariffValue(let l) = lhs, case .weekendTariffValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stateOfChargeProfileValue, .stateOfChargeProfileValue): return {
        guard case .stateOfChargeProfileValue(let l) = lhs, case .stateOfChargeProfileValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.weeklySettingsHeadUnitValue, .weeklySettingsHeadUnitValue): return {
        guard case .weeklySettingsHeadUnitValue(let l) = lhs, case .weeklySettingsHeadUnitValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.speedAlertConfigurationValue, .speedAlertConfigurationValue): return {
        guard case .speedAlertConfigurationValue(let l) = lhs, case .speedAlertConfigurationValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ecoHistogramValue, .ecoHistogramValue): return {
        guard case .ecoHistogramValue(let l) = lhs, case .ecoHistogramValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.weeklyProfileValue, .weeklyProfileValue): return {
        guard case .weeklyProfileValue(let l) = lhs, case .weeklyProfileValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargeProgramsValue, .chargeProgramsValue): return {
        guard case .chargeProgramsValue(let l) = lhs, case .chargeProgramsValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargingBreakClockTimer, .chargingBreakClockTimer): return {
        guard case .chargingBreakClockTimer(let l) = lhs, case .chargingBreakClockTimer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargingPowerControl, .chargingPowerControl): return {
        guard case .chargingPowerControl(let l) = lhs, case .chargingPowerControl(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum CombustionConsumptionUnit: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecifiedCombustionConsumptionUnit // = 0

    /// Liter per 100 km
    case literPer100Km // = 1

    /// Kilometers per liter
    case kmPerLiter // = 2

    /// Miles Per imperial gallon
    case mpgUk // = 3

    /// Miles Per US gallon
    case mpgUs // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecifiedCombustionConsumptionUnit
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedCombustionConsumptionUnit
      case 1: self = .literPer100Km
      case 2: self = .kmPerLiter
      case 3: self = .mpgUk
      case 4: self = .mpgUs
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecifiedCombustionConsumptionUnit: return 0
      case .literPer100Km: return 1
      case .kmPerLiter: return 2
      case .mpgUk: return 3
      case .mpgUs: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum ElectricityConsumptionUnit: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecifiedElectricityConsumptionUnit // = 0

    /// kWh per 100 km
    case kwhPer100Km // = 1

    /// Kilometers per kWh
    case kmPerKwh // = 2

    /// kWh per 100 miles
    case kwhPer100Mi // = 3

    /// miles per kWh
    case mPerKwh // = 4

    /// Miles per gallon gasoline equivalent
    case mpge // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecifiedElectricityConsumptionUnit
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedElectricityConsumptionUnit
      case 1: self = .kwhPer100Km
      case 2: self = .kmPerKwh
      case 3: self = .kwhPer100Mi
      case 4: self = .mPerKwh
      case 5: self = .mpge
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecifiedElectricityConsumptionUnit: return 0
      case .kwhPer100Km: return 1
      case .kmPerKwh: return 2
      case .kwhPer100Mi: return 3
      case .mPerKwh: return 4
      case .mpge: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum GasConsumptionUnit: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecifiedGasConsumptionUnit // = 0

    /// kG per 100 km
    case kgPer100Km // = 1

    /// km per kg
    case kmPerKg // = 2

    /// miles per kg
    case mPerKg // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecifiedGasConsumptionUnit
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedGasConsumptionUnit
      case 1: self = .kgPer100Km
      case 2: self = .kmPerKg
      case 3: self = .mPerKg
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecifiedGasConsumptionUnit: return 0
      case .kgPer100Km: return 1
      case .kmPerKg: return 2
      case .mPerKg: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum SpeedDistanceUnit: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecifiedSpeedDistanceUnit // = 0

    /// km/h, distance unit: km
    case kmPerH // = 1

    /// mph, distance unit: miles
    case mPerH // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecifiedSpeedDistanceUnit
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedSpeedDistanceUnit
      case 1: self = .kmPerH
      case 2: self = .mPerH
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecifiedSpeedDistanceUnit: return 0
      case .kmPerH: return 1
      case .mPerH: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum SpeedUnit: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecifiedSpeedUnit // = 0

    /// kilometers per hour
    case kmPerHour // = 1

    /// miles per hour
    case mPerHour // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecifiedSpeedUnit
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedSpeedUnit
      case 1: self = .kmPerHour
      case 2: self = .mPerHour
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecifiedSpeedUnit: return 0
      case .kmPerHour: return 1
      case .mPerHour: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum DistanceUnit: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecifiedDistanceUnit // = 0
    case kilometers // = 1
    case miles // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecifiedDistanceUnit
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedDistanceUnit
      case 1: self = .kilometers
      case 2: self = .miles
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecifiedDistanceUnit: return 0
      case .kilometers: return 1
      case .miles: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum TemperatureUnit: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecifiedTemperatureUnit // = 0
    case celsius // = 1
    case fahrenheit // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecifiedTemperatureUnit
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedTemperatureUnit
      case 1: self = .celsius
      case 2: self = .fahrenheit
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecifiedTemperatureUnit: return 0
      case .celsius: return 1
      case .fahrenheit: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum PressureUnit: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecifiedPressureUnit // = 0
    case kpa // = 1
    case bar // = 2

    /// Pounds per square inch
    case psi // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecifiedPressureUnit
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedPressureUnit
      case 1: self = .kpa
      case 2: self = .bar
      case 3: self = .psi
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecifiedPressureUnit: return 0
      case .kpa: return 1
      case .bar: return 2
      case .psi: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum RatioUnit: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecifiedRatioUnit // = 0
    case percent // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecifiedRatioUnit
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedRatioUnit
      case 1: self = .percent
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecifiedRatioUnit: return 0
      case .percent: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum ClockHourUnit: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecifiedClockHourUnit // = 0

    /// 12h (AM/PM)
    case t12H // = 1

    /// 24h
    case t24H // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecifiedClockHourUnit
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedClockHourUnit
      case 1: self = .t12H
      case 2: self = .t24H
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecifiedClockHourUnit: return 0
      case .t12H: return 1
      case .t24H: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_VehicleAttributeStatus.CombustionConsumptionUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_VehicleAttributeStatus.CombustionConsumptionUnit] = [
    .unspecifiedCombustionConsumptionUnit,
    .literPer100Km,
    .kmPerLiter,
    .mpgUk,
    .mpgUs,
  ]
}

extension Proto_VehicleAttributeStatus.ElectricityConsumptionUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_VehicleAttributeStatus.ElectricityConsumptionUnit] = [
    .unspecifiedElectricityConsumptionUnit,
    .kwhPer100Km,
    .kmPerKwh,
    .kwhPer100Mi,
    .mPerKwh,
    .mpge,
  ]
}

extension Proto_VehicleAttributeStatus.GasConsumptionUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_VehicleAttributeStatus.GasConsumptionUnit] = [
    .unspecifiedGasConsumptionUnit,
    .kgPer100Km,
    .kmPerKg,
    .mPerKg,
  ]
}

extension Proto_VehicleAttributeStatus.SpeedDistanceUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_VehicleAttributeStatus.SpeedDistanceUnit] = [
    .unspecifiedSpeedDistanceUnit,
    .kmPerH,
    .mPerH,
  ]
}

extension Proto_VehicleAttributeStatus.SpeedUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_VehicleAttributeStatus.SpeedUnit] = [
    .unspecifiedSpeedUnit,
    .kmPerHour,
    .mPerHour,
  ]
}

extension Proto_VehicleAttributeStatus.DistanceUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_VehicleAttributeStatus.DistanceUnit] = [
    .unspecifiedDistanceUnit,
    .kilometers,
    .miles,
  ]
}

extension Proto_VehicleAttributeStatus.TemperatureUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_VehicleAttributeStatus.TemperatureUnit] = [
    .unspecifiedTemperatureUnit,
    .celsius,
    .fahrenheit,
  ]
}

extension Proto_VehicleAttributeStatus.PressureUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_VehicleAttributeStatus.PressureUnit] = [
    .unspecifiedPressureUnit,
    .kpa,
    .bar,
    .psi,
  ]
}

extension Proto_VehicleAttributeStatus.RatioUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_VehicleAttributeStatus.RatioUnit] = [
    .unspecifiedRatioUnit,
    .percent,
  ]
}

extension Proto_VehicleAttributeStatus.ClockHourUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_VehicleAttributeStatus.ClockHourUnit] = [
    .unspecifiedClockHourUnit,
    .t12H,
    .t24H,
  ]
}

#endif  // swift(>=4.2)

struct Proto_ChargingBreakClockTimer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var clockTimer: [Proto_ChargingBreakClockTimerEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ChargingBreakClockTimerEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: Proto_ChargingBreakClockTimerAction = .delete

  var endTimeHour: Int32 = 0

  var endTimeMin: Int32 = 0

  var startTimeHour: Int32 = 0

  var startTimeMin: Int32 = 0

  var timerID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ChargingPowerControl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (–> Request to start/stop of charging/discharging, Anforderung zum Starten/Beenden des Lade-/Entladevorgangs)
  /// valid value range: 0-2
  var chargeStatus: Int32 = 0

  /// (–> Duration of request for remote controlled charging/discharging power, Dauer der ext. Anforderung Lade-/Ladeleistung)
  /// valid value range: 0..262142 s
  var ctrlDuration: Int32 = 0

  /// (–> Information response for the Service, Info-Rückmeldung zur ext. Einstellung der Lade-/Entladeleistung)
  /// valid value range: 0-14
  var ctrlInfo: Int32 = 0

  /// (–> Request for remote controlled charging/discharging power, Ext. Anforderung Lade-/ Entladeleistung)
  /// valid value range: 0 .. 30000
  var chargePower: Int32 = 0

  /// (–> Activation of remote control of charging/discharging power, Aktivierung der ext. Steuerung der Lade-/Entladeleistung)
  /// valid value range: 0-2
  var servStat: Int32 = 0

  /// (–> Confirmation of availability of service for remote control of charging/discharging power, Bestätigung der Verfügbarkeit des Service zur ext. Steuerung der Lade-/Entladeleistung)
  /// valid value range: 0-2
  var servAvail: Int32 = 0

  /// (–> Back-end use case requesting the service for remote control of charging/discharging power, Back-end use case, der die ext. Steuerung der Lade-/Entladeleistung anfordert)
  /// valid value range: 0-62
  var useCase: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ChargeProgramsValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeProgramParameters: [Proto_ChargeProgramParameters] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ChargeProgramParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeProgram: Proto_ChargeProgram = .defaultChargeProgram

  /// Values need to be between 50 and 100 and divisible by ten
  /// Maximum value for the state of charge of the HV battery [in %].
  /// Valid value range = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
  var maxSoc: Int32 = 0

  /// unlock the plug after charging is finished
  /// Denotes whether the charge cable should be unlocked automatically if the HV battery is fully charged resp. charged til Max. SoC value.
  /// true - unlock automatically, false - do not unlock automatically
  /// can only be used if chargeprogram is set to home or work. Otherwise it will be ignored.
  var autoUnlock: Bool = false

  /// automatically switch between home and work program, based on the location of the car
  /// Denotes whether location based charging should be used.
  /// true - use location based charging, false - do not use location based charging
  /// can only be used if chargeprogram is set to home or work. Otherwise it will be ignored.
  var locationBasedCharging: Bool = false

  var weeklyProfile: Bool = false

  var clockTimer: Bool = false

  var maxChargingCurrent: Int32 = 0

  var ecoCharging: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WeeklyProfileValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var singleTimeProfileEntriesActivatable: Bool = false

  var maxNumberOfWeeklyTimeProfileSlots: Int32 = 0

  var maxNumberOfTimeProfiles: Int32 = 0

  var currentNumberOfTimeProfileSlots: Int32 = 0

  var currentNumberOfTimeProfiles: Int32 = 0

  var timeProfiles: [Proto_VVRTimeProfile] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// VVRTimeProfile is almost identical to the "TimeProfile" message with the exception that the identifier is not optional.
struct Proto_VVRTimeProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique id of this time profile entry
  var identifier: Int32 = 0

  /// Hour after midnight range [0, 23]
  var hour: Int32 = 0

  /// Minute after full hour range [0, 59]
  var minute: Int32 = 0

  /// Days for which the above time should be applied
  var days: [Proto_TimeProfileDay] = []

  /// Whether this profile entry is active or not
  var active: Bool = false

  /// If a timeProfile is changed or added the respective applicationId must be provided by SDK
  ///   11 = Internal Apps
  ///   12 = External Apps
  var applicationIdentifier: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_EcoHistogramValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ecoHistogramBins: [Proto_EcoHistogramBin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_EcoHistogramBin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var interval: Double = 0

  var value: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SpeedAlertConfigurationValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var speedAlertConfigurations: [Proto_SpeedAlertConfiguration] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SpeedAlertConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unix timestamp in seconds
  var endTimestampInS: Int64 = 0

  /// Speed in kilometers per hour
  var thresholdInKph: Int32 = 0

  /// threshold value in the users preferred unit
  var thresholdDisplayValue: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WeeklySettingsHeadUnitValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Array with 0 to 21 tupels of day (0..6, 0 = Monday, 1= Tuesday, ..) and departure time in min since midnight (0..1439)
  var weeklySettings: [Proto_WeeklySetting] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WeeklySetting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var day: Int32 = 0

  var minutesSinceMidnight: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_TemperaturePointsValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Array with 1 to 5 tupels of zone (frontLeft, frontRight, frontCenter, rearRight, rearLeft, rearCenter, rear2center)
  /// and temperature in °C where 0 means maximum cooling (LOW) and 30 means maximum heating (HIGH)
  var temperaturePoints: [Proto_TemperaturePoint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_TemperaturePoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var zone: String = String()

  var temperature: Double = 0

  var temperatureDisplayValue: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WeekdayTariffValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of sampling points. Hint: Array will be empty in initial state. I. e.: rate and time will not be existent in initial state.
  var tariffs: [Proto_Tariff] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WeekendTariffValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of sampling points. Hint: Array will be empty in initial state. I. e.: rate and time will not be existent in initial state.
  var tariffs: [Proto_Tariff] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_Tariff {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 33 - off-peak, 44 - mid-peak, 66 - on-peak
  var rate: Int32 = 0

  /// Seconds from midnight
  var time: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_StateOfChargeProfileValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Array with tupels of state of charge and time offset related to the timestamp of the attribute,
  /// e.g. [{t, soc}, {t, soc}, .., {t, soc}] (every soc with value range 0..100, every timestamp in seconds, UTC)
  var statesOfCharge: [Proto_StateOfCharge] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_StateOfCharge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// timestamp in seconds, UTC
  var timestampInS: Int64 = 0

  /// soc with value range 0..100
  var stateOfCharge: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Sending direction: App <- Websocket-Service <- AppTwin
struct Proto_VEPUpdatesByVIN {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  /// VIN -> Update
  var updates: Dictionary<String,Proto_VEPUpdate> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Sending direction: App <- Websocket-Service
struct Proto_DebugMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a status response from the
/// VVA backend for a given VIN and CIAM ID.
struct Proto_VehicleStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vin: String = String()

  var attributes: Dictionary<String,Proto_VehicleAttributeStatus> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// message that is pushed from the vep status service
/// Sending direction: App <- Websocket-Service
struct Proto_PushMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trackingID: String = String()

  var msg: Proto_PushMessage.OneOf_Msg? = nil

  var vepUpdate: Proto_VEPUpdate {
    get {
      if case .vepUpdate(let v)? = msg {return v}
      return Proto_VEPUpdate()
    }
    set {msg = .vepUpdate(newValue)}
  }

  var vepUpdates: Proto_VEPUpdatesByVIN {
    get {
      if case .vepUpdates(let v)? = msg {return v}
      return Proto_VEPUpdatesByVIN()
    }
    set {msg = .vepUpdates(newValue)}
  }

  var debugMessage: Proto_DebugMessage {
    get {
      if case .debugMessage(let v)? = msg {return v}
      return Proto_DebugMessage()
    }
    set {msg = .debugMessage(newValue)}
  }

  var serviceStatusUpdates: Proto_ServiceStatusUpdatesByVIN {
    get {
      if case .serviceStatusUpdates(let v)? = msg {return v}
      return Proto_ServiceStatusUpdatesByVIN()
    }
    set {msg = .serviceStatusUpdates(newValue)}
  }

  var serviceStatusUpdate: Proto_ServiceStatusUpdate {
    get {
      if case .serviceStatusUpdate(let v)? = msg {return v}
      return Proto_ServiceStatusUpdate()
    }
    set {msg = .serviceStatusUpdate(newValue)}
  }

  var userDataUpdate: Proto_UserDataUpdate {
    get {
      if case .userDataUpdate(let v)? = msg {return v}
      return Proto_UserDataUpdate()
    }
    set {msg = .userDataUpdate(newValue)}
  }

  var userVehicleAuthChangedUpdate: Proto_UserVehicleAuthChangedUpdate {
    get {
      if case .userVehicleAuthChangedUpdate(let v)? = msg {return v}
      return Proto_UserVehicleAuthChangedUpdate()
    }
    set {msg = .userVehicleAuthChangedUpdate(newValue)}
  }

  var userPictureUpdate: Proto_UserPictureUpdate {
    get {
      if case .userPictureUpdate(let v)? = msg {return v}
      return Proto_UserPictureUpdate()
    }
    set {msg = .userPictureUpdate(newValue)}
  }

  var userPinUpdate: Proto_UserPINUpdate {
    get {
      if case .userPinUpdate(let v)? = msg {return v}
      return Proto_UserPINUpdate()
    }
    set {msg = .userPinUpdate(newValue)}
  }

  var vehicleUpdated: Proto_VehicleUpdated {
    get {
      if case .vehicleUpdated(let v)? = msg {return v}
      return Proto_VehicleUpdated()
    }
    set {msg = .vehicleUpdated(newValue)}
  }

  var preferredDealerChange: Proto_PreferredDealerChange {
    get {
      if case .preferredDealerChange(let v)? = msg {return v}
      return Proto_PreferredDealerChange()
    }
    set {msg = .preferredDealerChange(newValue)}
  }

  var apptwinCommandStatusUpdatesByVin: Proto_AppTwinCommandStatusUpdatesByVIN {
    get {
      if case .apptwinCommandStatusUpdatesByVin(let v)? = msg {return v}
      return Proto_AppTwinCommandStatusUpdatesByVIN()
    }
    set {msg = .apptwinCommandStatusUpdatesByVin(newValue)}
  }

  var apptwinPendingCommandRequest: Proto_AppTwinPendingCommandsRequest {
    get {
      if case .apptwinPendingCommandRequest(let v)? = msg {return v}
      return Proto_AppTwinPendingCommandsRequest()
    }
    set {msg = .apptwinPendingCommandRequest(newValue)}
  }

  var assignedVehicles: Proto_AssignedVehicles {
    get {
      if case .assignedVehicles(let v)? = msg {return v}
      return Proto_AssignedVehicles()
    }
    set {msg = .assignedVehicles(newValue)}
  }

  var persPinStatusChange: Proto_PersPinStatusChangeUpdate {
    get {
      if case .persPinStatusChange(let v)? = msg {return v}
      return Proto_PersPinStatusChangeUpdate()
    }
    set {msg = .persPinStatusChange(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable {
    case vepUpdate(Proto_VEPUpdate)
    case vepUpdates(Proto_VEPUpdatesByVIN)
    case debugMessage(Proto_DebugMessage)
    case serviceStatusUpdates(Proto_ServiceStatusUpdatesByVIN)
    case serviceStatusUpdate(Proto_ServiceStatusUpdate)
    case userDataUpdate(Proto_UserDataUpdate)
    case userVehicleAuthChangedUpdate(Proto_UserVehicleAuthChangedUpdate)
    case userPictureUpdate(Proto_UserPictureUpdate)
    case userPinUpdate(Proto_UserPINUpdate)
    case vehicleUpdated(Proto_VehicleUpdated)
    case preferredDealerChange(Proto_PreferredDealerChange)
    case apptwinCommandStatusUpdatesByVin(Proto_AppTwinCommandStatusUpdatesByVIN)
    case apptwinPendingCommandRequest(Proto_AppTwinPendingCommandsRequest)
    case assignedVehicles(Proto_AssignedVehicles)
    case persPinStatusChange(Proto_PersPinStatusChangeUpdate)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_PushMessage.OneOf_Msg, rhs: Proto_PushMessage.OneOf_Msg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.vepUpdate, .vepUpdate): return {
        guard case .vepUpdate(let l) = lhs, case .vepUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vepUpdates, .vepUpdates): return {
        guard case .vepUpdates(let l) = lhs, case .vepUpdates(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.debugMessage, .debugMessage): return {
        guard case .debugMessage(let l) = lhs, case .debugMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.serviceStatusUpdates, .serviceStatusUpdates): return {
        guard case .serviceStatusUpdates(let l) = lhs, case .serviceStatusUpdates(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.serviceStatusUpdate, .serviceStatusUpdate): return {
        guard case .serviceStatusUpdate(let l) = lhs, case .serviceStatusUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userDataUpdate, .userDataUpdate): return {
        guard case .userDataUpdate(let l) = lhs, case .userDataUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userVehicleAuthChangedUpdate, .userVehicleAuthChangedUpdate): return {
        guard case .userVehicleAuthChangedUpdate(let l) = lhs, case .userVehicleAuthChangedUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userPictureUpdate, .userPictureUpdate): return {
        guard case .userPictureUpdate(let l) = lhs, case .userPictureUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userPinUpdate, .userPinUpdate): return {
        guard case .userPinUpdate(let l) = lhs, case .userPinUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleUpdated, .vehicleUpdated): return {
        guard case .vehicleUpdated(let l) = lhs, case .vehicleUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.preferredDealerChange, .preferredDealerChange): return {
        guard case .preferredDealerChange(let l) = lhs, case .preferredDealerChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.apptwinCommandStatusUpdatesByVin, .apptwinCommandStatusUpdatesByVin): return {
        guard case .apptwinCommandStatusUpdatesByVin(let l) = lhs, case .apptwinCommandStatusUpdatesByVin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.apptwinPendingCommandRequest, .apptwinPendingCommandRequest): return {
        guard case .apptwinPendingCommandRequest(let l) = lhs, case .apptwinPendingCommandRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.assignedVehicles, .assignedVehicles): return {
        guard case .assignedVehicles(let l) = lhs, case .assignedVehicles(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.persPinStatusChange, .persPinStatusChange): return {
        guard case .persPinStatusChange(let l) = lhs, case .persPinStatusChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// message type to track an event, e.g. a user interaction with content
/// Sending direction: App -> Websocket-Service
struct Proto_TrackingEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// a unique id associated with this event
  var trackingID: String = String()

  /// the unix epoch time in nanoseconds when the event occurred
  var timestamp: Int64 = 0

  /// a unique identifier describing a single interaction or event
  var eventType: String = String()

  /// additional meta data describing the event
  var payload: Dictionary<String,Proto_PayloadValue> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_PayloadValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: Proto_PayloadValue.OneOf_Msg? = nil

  var stringValue: String {
    get {
      if case .stringValue(let v)? = msg {return v}
      return String()
    }
    set {msg = .stringValue(newValue)}
  }

  var intValue: Int32 {
    get {
      if case .intValue(let v)? = msg {return v}
      return 0
    }
    set {msg = .intValue(newValue)}
  }

  var boolValue: Bool {
    get {
      if case .boolValue(let v)? = msg {return v}
      return false
    }
    set {msg = .boolValue(newValue)}
  }

  var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = msg {return v}
      return 0
    }
    set {msg = .doubleValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable {
    case stringValue(String)
    case intValue(Int32)
    case boolValue(Bool)
    case doubleValue(Double)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_PayloadValue.OneOf_Msg, rhs: Proto_PayloadValue.OneOf_Msg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intValue, .intValue): return {
        guard case .intValue(let l) = lhs, case .intValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.boolValue, .boolValue): return {
        guard case .boolValue(let l) = lhs, case .boolValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleValue, .doubleValue): return {
        guard case .doubleValue(let l) = lhs, case .doubleValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// acknowledge that the VEP updates of up to `sequenceNumber` have been received
/// Sending direction: App -> Websocket-Service -> AppTwin
struct Proto_AcknowledgeVEPRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// acknowledge that the VEP updates by vin of up to `sequenceNumber` have been received
/// Sending direction: App -> Websocket-Service -> AppTwin
/// This message should replace the AcknowledgeVEPRequest
struct Proto_AcknowledgeVEPUpdatesByVIN {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// the client can optionally send this message to reconfigure the ping interval
/// Sending direction: App -> Websocket-Service
struct Proto_ConfigurePingInterval {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pingTimeMillis: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AcknowledgeVehicleUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AcknowledgePreferredDealerChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_VehicleUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var ciamID: String = String()

  var vin: String = String()

  /// When was the event emitted (milliseconds in Unix time)
  var emitTimestampInMs: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_PreferredDealerChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var ciamID: String = String()

  var vin: String = String()

  /// When was the event emitted (milliseconds in Unix time)
  var emitTimestampInMs: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_ChargingBreakClockTimerAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DELETE"),
    1: .same(proto: "ACTIVATE"),
    2: .same(proto: "DEACTIVATE"),
  ]
}

extension Proto_ChargeProgram: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT_CHARGE_PROGRAM"),
    1: .same(proto: "INSTANT_CHARGE_PROGRAM"),
    2: .same(proto: "HOME_CHARGE_PROGRAM"),
    3: .same(proto: "WORK_CHARGE_PROGRAM"),
  ]
}

extension Proto_AttributeStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VALUE_VALID"),
    1: .same(proto: "VALUE_NOT_RECEIVED"),
    3: .same(proto: "VALUE_INVALID"),
    4: .same(proto: "VALUE_NOT_AVAILABLE"),
  ]
}

extension Proto_VEPUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VEPUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    2: .same(proto: "vin"),
    15: .standard(proto: "full_update"),
    10: .standard(proto: "emit_timestamp"),
    14: .standard(proto: "emit_timestamp_in_ms"),
    11: .same(proto: "attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.vin) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestamp) }()
      case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto_VehicleAttributeStatus>.self, value: &self.attributes) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestampInMs) }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self.fullUpdate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    if !self.vin.isEmpty {
      try visitor.visitSingularStringField(value: self.vin, fieldNumber: 2)
    }
    if self.emitTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestamp, fieldNumber: 10)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto_VehicleAttributeStatus>.self, value: self.attributes, fieldNumber: 11)
    }
    if self.emitTimestampInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestampInMs, fieldNumber: 14)
    }
    if self.fullUpdate != false {
      try visitor.visitSingularBoolField(value: self.fullUpdate, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_VEPUpdate, rhs: Proto_VEPUpdate) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.vin != rhs.vin {return false}
    if lhs.fullUpdate != rhs.fullUpdate {return false}
    if lhs.emitTimestamp != rhs.emitTimestamp {return false}
    if lhs.emitTimestampInMs != rhs.emitTimestampInMs {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_VehicleAttributeStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleAttributeStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    10: .standard(proto: "timestamp_in_ms"),
    2: .same(proto: "changed"),
    3: .same(proto: "status"),
    30: .standard(proto: "service_ids"),
    11: .standard(proto: "display_value"),
    12: .standard(proto: "combustion_consumption_unit"),
    13: .standard(proto: "gas_consumption_unit"),
    14: .standard(proto: "electricity_consumption_unit"),
    15: .standard(proto: "speed_distance_unit"),
    25: .standard(proto: "speed_unit"),
    26: .standard(proto: "distance_unit"),
    16: .standard(proto: "temperature_unit"),
    17: .standard(proto: "pressure_unit"),
    18: .standard(proto: "ratio_unit"),
    19: .standard(proto: "clock_hour_unit"),
    4: .standard(proto: "int_value"),
    5: .standard(proto: "bool_value"),
    6: .standard(proto: "string_value"),
    7: .standard(proto: "double_value"),
    8: .standard(proto: "nil_value"),
    9: .standard(proto: "unsupported_value"),
    20: .standard(proto: "temperature_points_value"),
    21: .standard(proto: "weekday_tariff_value"),
    22: .standard(proto: "weekend_tariff_value"),
    23: .standard(proto: "state_of_charge_profile_value"),
    24: .standard(proto: "weekly_settings_head_unit_value"),
    27: .standard(proto: "speed_alert_configuration_value"),
    28: .standard(proto: "eco_histogram_value"),
    29: .standard(proto: "weekly_profile_value"),
    31: .standard(proto: "charge_programs_value"),
    32: .standard(proto: "charging_break_clock_timer"),
    33: .standard(proto: "charging_power_control"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.changed) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 4: try {
        if self.attributeType != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.attributeType = .intValue(v)}
      }()
      case 5: try {
        if self.attributeType != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.attributeType = .boolValue(v)}
      }()
      case 6: try {
        if self.attributeType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.attributeType = .stringValue(v)}
      }()
      case 7: try {
        if self.attributeType != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.attributeType = .doubleValue(v)}
      }()
      case 8: try {
        if self.attributeType != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.attributeType = .nilValue(v)}
      }()
      case 9: try {
        if self.attributeType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.attributeType = .unsupportedValue(v)}
      }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.timestampInMs) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.displayValue) }()
      case 12: try {
        if self.displayUnit != nil {try decoder.handleConflictingOneOf()}
        var v: Proto_VehicleAttributeStatus.CombustionConsumptionUnit?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.displayUnit = .combustionConsumptionUnit(v)}
      }()
      case 13: try {
        if self.displayUnit != nil {try decoder.handleConflictingOneOf()}
        var v: Proto_VehicleAttributeStatus.GasConsumptionUnit?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.displayUnit = .gasConsumptionUnit(v)}
      }()
      case 14: try {
        if self.displayUnit != nil {try decoder.handleConflictingOneOf()}
        var v: Proto_VehicleAttributeStatus.ElectricityConsumptionUnit?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.displayUnit = .electricityConsumptionUnit(v)}
      }()
      case 15: try {
        if self.displayUnit != nil {try decoder.handleConflictingOneOf()}
        var v: Proto_VehicleAttributeStatus.SpeedDistanceUnit?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.displayUnit = .speedDistanceUnit(v)}
      }()
      case 16: try {
        if self.displayUnit != nil {try decoder.handleConflictingOneOf()}
        var v: Proto_VehicleAttributeStatus.TemperatureUnit?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.displayUnit = .temperatureUnit(v)}
      }()
      case 17: try {
        if self.displayUnit != nil {try decoder.handleConflictingOneOf()}
        var v: Proto_VehicleAttributeStatus.PressureUnit?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.displayUnit = .pressureUnit(v)}
      }()
      case 18: try {
        if self.displayUnit != nil {try decoder.handleConflictingOneOf()}
        var v: Proto_VehicleAttributeStatus.RatioUnit?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.displayUnit = .ratioUnit(v)}
      }()
      case 19: try {
        if self.displayUnit != nil {try decoder.handleConflictingOneOf()}
        var v: Proto_VehicleAttributeStatus.ClockHourUnit?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.displayUnit = .clockHourUnit(v)}
      }()
      case 20: try {
        var v: Proto_TemperaturePointsValue?
        if let current = self.attributeType {
          try decoder.handleConflictingOneOf()
          if case .temperaturePointsValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.attributeType = .temperaturePointsValue(v)}
      }()
      case 21: try {
        var v: Proto_WeekdayTariffValue?
        if let current = self.attributeType {
          try decoder.handleConflictingOneOf()
          if case .weekdayTariffValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.attributeType = .weekdayTariffValue(v)}
      }()
      case 22: try {
        var v: Proto_WeekendTariffValue?
        if let current = self.attributeType {
          try decoder.handleConflictingOneOf()
          if case .weekendTariffValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.attributeType = .weekendTariffValue(v)}
      }()
      case 23: try {
        var v: Proto_StateOfChargeProfileValue?
        if let current = self.attributeType {
          try decoder.handleConflictingOneOf()
          if case .stateOfChargeProfileValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.attributeType = .stateOfChargeProfileValue(v)}
      }()
      case 24: try {
        var v: Proto_WeeklySettingsHeadUnitValue?
        if let current = self.attributeType {
          try decoder.handleConflictingOneOf()
          if case .weeklySettingsHeadUnitValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.attributeType = .weeklySettingsHeadUnitValue(v)}
      }()
      case 25: try {
        if self.displayUnit != nil {try decoder.handleConflictingOneOf()}
        var v: Proto_VehicleAttributeStatus.SpeedUnit?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.displayUnit = .speedUnit(v)}
      }()
      case 26: try {
        if self.displayUnit != nil {try decoder.handleConflictingOneOf()}
        var v: Proto_VehicleAttributeStatus.DistanceUnit?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.displayUnit = .distanceUnit(v)}
      }()
      case 27: try {
        var v: Proto_SpeedAlertConfigurationValue?
        if let current = self.attributeType {
          try decoder.handleConflictingOneOf()
          if case .speedAlertConfigurationValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.attributeType = .speedAlertConfigurationValue(v)}
      }()
      case 28: try {
        var v: Proto_EcoHistogramValue?
        if let current = self.attributeType {
          try decoder.handleConflictingOneOf()
          if case .ecoHistogramValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.attributeType = .ecoHistogramValue(v)}
      }()
      case 29: try {
        var v: Proto_WeeklyProfileValue?
        if let current = self.attributeType {
          try decoder.handleConflictingOneOf()
          if case .weeklyProfileValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.attributeType = .weeklyProfileValue(v)}
      }()
      case 30: try { try decoder.decodeRepeatedInt32Field(value: &self.serviceIds) }()
      case 31: try {
        var v: Proto_ChargeProgramsValue?
        if let current = self.attributeType {
          try decoder.handleConflictingOneOf()
          if case .chargeProgramsValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.attributeType = .chargeProgramsValue(v)}
      }()
      case 32: try {
        var v: Proto_ChargingBreakClockTimer?
        if let current = self.attributeType {
          try decoder.handleConflictingOneOf()
          if case .chargingBreakClockTimer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.attributeType = .chargingBreakClockTimer(v)}
      }()
      case 33: try {
        var v: Proto_ChargingPowerControl?
        if let current = self.attributeType {
          try decoder.handleConflictingOneOf()
          if case .chargingPowerControl(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.attributeType = .chargingPowerControl(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.changed != false {
      try visitor.visitSingularBoolField(value: self.changed, fieldNumber: 2)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.attributeType {
    case .intValue?: try {
      guard case .intValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 7)
    }()
    case .nilValue?: try {
      guard case .nilValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case .unsupportedValue?: try {
      guard case .unsupportedValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }()
    default: break
    }
    if self.timestampInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampInMs, fieldNumber: 10)
    }
    if !self.displayValue.isEmpty {
      try visitor.visitSingularStringField(value: self.displayValue, fieldNumber: 11)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.displayUnit {
    case .combustionConsumptionUnit?: try {
      guard case .combustionConsumptionUnit(let v)? = self.displayUnit else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
    }()
    case .gasConsumptionUnit?: try {
      guard case .gasConsumptionUnit(let v)? = self.displayUnit else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
    }()
    case .electricityConsumptionUnit?: try {
      guard case .electricityConsumptionUnit(let v)? = self.displayUnit else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 14)
    }()
    case .speedDistanceUnit?: try {
      guard case .speedDistanceUnit(let v)? = self.displayUnit else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 15)
    }()
    case .temperatureUnit?: try {
      guard case .temperatureUnit(let v)? = self.displayUnit else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 16)
    }()
    case .pressureUnit?: try {
      guard case .pressureUnit(let v)? = self.displayUnit else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 17)
    }()
    case .ratioUnit?: try {
      guard case .ratioUnit(let v)? = self.displayUnit else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 18)
    }()
    case .clockHourUnit?: try {
      guard case .clockHourUnit(let v)? = self.displayUnit else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 19)
    }()
    default: break
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.attributeType {
    case .temperaturePointsValue?: try {
      guard case .temperaturePointsValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .weekdayTariffValue?: try {
      guard case .weekdayTariffValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .weekendTariffValue?: try {
      guard case .weekendTariffValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .stateOfChargeProfileValue?: try {
      guard case .stateOfChargeProfileValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .weeklySettingsHeadUnitValue?: try {
      guard case .weeklySettingsHeadUnitValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    default: break
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.displayUnit {
    case .speedUnit?: try {
      guard case .speedUnit(let v)? = self.displayUnit else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 25)
    }()
    case .distanceUnit?: try {
      guard case .distanceUnit(let v)? = self.displayUnit else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 26)
    }()
    default: break
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.attributeType {
    case .speedAlertConfigurationValue?: try {
      guard case .speedAlertConfigurationValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .ecoHistogramValue?: try {
      guard case .ecoHistogramValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .weeklyProfileValue?: try {
      guard case .weeklyProfileValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    default: break
    }
    if !self.serviceIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.serviceIds, fieldNumber: 30)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.attributeType {
    case .chargeProgramsValue?: try {
      guard case .chargeProgramsValue(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .chargingBreakClockTimer?: try {
      guard case .chargingBreakClockTimer(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .chargingPowerControl?: try {
      guard case .chargingPowerControl(let v)? = self.attributeType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_VehicleAttributeStatus, rhs: Proto_VehicleAttributeStatus) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.timestampInMs != rhs.timestampInMs {return false}
    if lhs.changed != rhs.changed {return false}
    if lhs.status != rhs.status {return false}
    if lhs.serviceIds != rhs.serviceIds {return false}
    if lhs.displayValue != rhs.displayValue {return false}
    if lhs.displayUnit != rhs.displayUnit {return false}
    if lhs.attributeType != rhs.attributeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_VehicleAttributeStatus.CombustionConsumptionUnit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_COMBUSTION_CONSUMPTION_UNIT"),
    1: .same(proto: "LITER_PER_100KM"),
    2: .same(proto: "KM_PER_LITER"),
    3: .same(proto: "MPG_UK"),
    4: .same(proto: "MPG_US"),
  ]
}

extension Proto_VehicleAttributeStatus.ElectricityConsumptionUnit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_ELECTRICITY_CONSUMPTION_UNIT"),
    1: .same(proto: "KWH_PER_100KM"),
    2: .same(proto: "KM_PER_KWH"),
    3: .same(proto: "KWH_PER_100MI"),
    4: .same(proto: "M_PER_KWH"),
    5: .same(proto: "MPGE"),
  ]
}

extension Proto_VehicleAttributeStatus.GasConsumptionUnit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_GAS_CONSUMPTION_UNIT"),
    1: .same(proto: "KG_PER_100KM"),
    2: .same(proto: "KM_PER_KG"),
    3: .same(proto: "M_PER_KG"),
  ]
}

extension Proto_VehicleAttributeStatus.SpeedDistanceUnit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_SPEED_DISTANCE_UNIT"),
    1: .same(proto: "KM_PER_H"),
    2: .same(proto: "M_PER_H"),
  ]
}

extension Proto_VehicleAttributeStatus.SpeedUnit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_SPEED_UNIT"),
    1: .same(proto: "KM_PER_HOUR"),
    2: .same(proto: "M_PER_HOUR"),
  ]
}

extension Proto_VehicleAttributeStatus.DistanceUnit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_DISTANCE_UNIT"),
    1: .same(proto: "KILOMETERS"),
    2: .same(proto: "MILES"),
  ]
}

extension Proto_VehicleAttributeStatus.TemperatureUnit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_TEMPERATURE_UNIT"),
    1: .same(proto: "CELSIUS"),
    2: .same(proto: "FAHRENHEIT"),
  ]
}

extension Proto_VehicleAttributeStatus.PressureUnit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_PRESSURE_UNIT"),
    1: .same(proto: "KPA"),
    2: .same(proto: "BAR"),
    3: .same(proto: "PSI"),
  ]
}

extension Proto_VehicleAttributeStatus.RatioUnit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_RATIO_UNIT"),
    1: .same(proto: "PERCENT"),
  ]
}

extension Proto_VehicleAttributeStatus.ClockHourUnit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_CLOCK_HOUR_UNIT"),
    1: .same(proto: "T12H"),
    2: .same(proto: "T24H"),
  ]
}

extension Proto_ChargingBreakClockTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargingBreakClockTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "clock_timer", json: "clocktimer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.clockTimer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clockTimer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clockTimer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargingBreakClockTimer, rhs: Proto_ChargingBreakClockTimer) -> Bool {
    if lhs.clockTimer != rhs.clockTimer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargingBreakClockTimerEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargingBreakClockTimerEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "end_time_hour"),
    3: .standard(proto: "end_time_min"),
    4: .standard(proto: "start_time_hour"),
    5: .standard(proto: "start_time_min"),
    6: .standard(proto: "timer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.endTimeHour) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.endTimeMin) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.startTimeHour) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.startTimeMin) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.timerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .delete {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if self.endTimeHour != 0 {
      try visitor.visitSingularInt32Field(value: self.endTimeHour, fieldNumber: 2)
    }
    if self.endTimeMin != 0 {
      try visitor.visitSingularInt32Field(value: self.endTimeMin, fieldNumber: 3)
    }
    if self.startTimeHour != 0 {
      try visitor.visitSingularInt32Field(value: self.startTimeHour, fieldNumber: 4)
    }
    if self.startTimeMin != 0 {
      try visitor.visitSingularInt32Field(value: self.startTimeMin, fieldNumber: 5)
    }
    if self.timerID != 0 {
      try visitor.visitSingularInt64Field(value: self.timerID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargingBreakClockTimerEntry, rhs: Proto_ChargingBreakClockTimerEntry) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.endTimeHour != rhs.endTimeHour {return false}
    if lhs.endTimeMin != rhs.endTimeMin {return false}
    if lhs.startTimeHour != rhs.startTimeHour {return false}
    if lhs.startTimeMin != rhs.startTimeMin {return false}
    if lhs.timerID != rhs.timerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargingPowerControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargingPowerControl"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "charge_status", json: "ChrgStat"),
    2: .unique(proto: "ctrl_duration", json: "CtrlDur [s]"),
    3: .unique(proto: "ctrl_info", json: "CtrlInfo"),
    4: .unique(proto: "charge_power", json: "ChrgPwr [kW]"),
    5: .unique(proto: "serv_stat", json: "ServStat"),
    6: .unique(proto: "serv_avail", json: "ServAvail"),
    7: .unique(proto: "use_case", json: "UseCase"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.chargeStatus) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.ctrlDuration) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.ctrlInfo) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.chargePower) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.servStat) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.servAvail) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.useCase) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chargeStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.chargeStatus, fieldNumber: 1)
    }
    if self.ctrlDuration != 0 {
      try visitor.visitSingularInt32Field(value: self.ctrlDuration, fieldNumber: 2)
    }
    if self.ctrlInfo != 0 {
      try visitor.visitSingularInt32Field(value: self.ctrlInfo, fieldNumber: 3)
    }
    if self.chargePower != 0 {
      try visitor.visitSingularInt32Field(value: self.chargePower, fieldNumber: 4)
    }
    if self.servStat != 0 {
      try visitor.visitSingularInt32Field(value: self.servStat, fieldNumber: 5)
    }
    if self.servAvail != 0 {
      try visitor.visitSingularInt32Field(value: self.servAvail, fieldNumber: 6)
    }
    if self.useCase != 0 {
      try visitor.visitSingularInt32Field(value: self.useCase, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargingPowerControl, rhs: Proto_ChargingPowerControl) -> Bool {
    if lhs.chargeStatus != rhs.chargeStatus {return false}
    if lhs.ctrlDuration != rhs.ctrlDuration {return false}
    if lhs.ctrlInfo != rhs.ctrlInfo {return false}
    if lhs.chargePower != rhs.chargePower {return false}
    if lhs.servStat != rhs.servStat {return false}
    if lhs.servAvail != rhs.servAvail {return false}
    if lhs.useCase != rhs.useCase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeProgramsValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeProgramsValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "charge_program_parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chargeProgramParameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chargeProgramParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chargeProgramParameters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeProgramsValue, rhs: Proto_ChargeProgramsValue) -> Bool {
    if lhs.chargeProgramParameters != rhs.chargeProgramParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeProgramParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeProgramParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "charge_program", json: "chargeprogram"),
    2: .standard(proto: "max_soc"),
    3: .unique(proto: "auto_unlock", json: "autounlock"),
    4: .unique(proto: "location_based_charging", json: "locationbasedcharging"),
    5: .unique(proto: "weekly_profile", json: "weeklyprofile"),
    6: .same(proto: "clockTimer"),
    7: .unique(proto: "max_charging_current", json: "MaxChargingCurrent"),
    8: .unique(proto: "eco_charging", json: "EcoCharging"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.chargeProgram) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxSoc) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.autoUnlock) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.locationBasedCharging) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.weeklyProfile) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.clockTimer) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.maxChargingCurrent) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.ecoCharging) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chargeProgram != .defaultChargeProgram {
      try visitor.visitSingularEnumField(value: self.chargeProgram, fieldNumber: 1)
    }
    if self.maxSoc != 0 {
      try visitor.visitSingularInt32Field(value: self.maxSoc, fieldNumber: 2)
    }
    if self.autoUnlock != false {
      try visitor.visitSingularBoolField(value: self.autoUnlock, fieldNumber: 3)
    }
    if self.locationBasedCharging != false {
      try visitor.visitSingularBoolField(value: self.locationBasedCharging, fieldNumber: 4)
    }
    if self.weeklyProfile != false {
      try visitor.visitSingularBoolField(value: self.weeklyProfile, fieldNumber: 5)
    }
    if self.clockTimer != false {
      try visitor.visitSingularBoolField(value: self.clockTimer, fieldNumber: 6)
    }
    if self.maxChargingCurrent != 0 {
      try visitor.visitSingularInt32Field(value: self.maxChargingCurrent, fieldNumber: 7)
    }
    if self.ecoCharging != false {
      try visitor.visitSingularBoolField(value: self.ecoCharging, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeProgramParameters, rhs: Proto_ChargeProgramParameters) -> Bool {
    if lhs.chargeProgram != rhs.chargeProgram {return false}
    if lhs.maxSoc != rhs.maxSoc {return false}
    if lhs.autoUnlock != rhs.autoUnlock {return false}
    if lhs.locationBasedCharging != rhs.locationBasedCharging {return false}
    if lhs.weeklyProfile != rhs.weeklyProfile {return false}
    if lhs.clockTimer != rhs.clockTimer {return false}
    if lhs.maxChargingCurrent != rhs.maxChargingCurrent {return false}
    if lhs.ecoCharging != rhs.ecoCharging {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WeeklyProfileValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeeklyProfileValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "single_time_profile_entries_activatable"),
    2: .standard(proto: "max_number_of_weekly_time_profile_slots"),
    3: .standard(proto: "max_number_of_time_profiles"),
    4: .standard(proto: "current_number_of_time_profile_slots"),
    5: .standard(proto: "current_number_of_time_profiles"),
    6: .standard(proto: "time_profiles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.singleTimeProfileEntriesActivatable) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxNumberOfWeeklyTimeProfileSlots) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxNumberOfTimeProfiles) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.currentNumberOfTimeProfileSlots) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.currentNumberOfTimeProfiles) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.timeProfiles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.singleTimeProfileEntriesActivatable != false {
      try visitor.visitSingularBoolField(value: self.singleTimeProfileEntriesActivatable, fieldNumber: 1)
    }
    if self.maxNumberOfWeeklyTimeProfileSlots != 0 {
      try visitor.visitSingularInt32Field(value: self.maxNumberOfWeeklyTimeProfileSlots, fieldNumber: 2)
    }
    if self.maxNumberOfTimeProfiles != 0 {
      try visitor.visitSingularInt32Field(value: self.maxNumberOfTimeProfiles, fieldNumber: 3)
    }
    if self.currentNumberOfTimeProfileSlots != 0 {
      try visitor.visitSingularInt32Field(value: self.currentNumberOfTimeProfileSlots, fieldNumber: 4)
    }
    if self.currentNumberOfTimeProfiles != 0 {
      try visitor.visitSingularInt32Field(value: self.currentNumberOfTimeProfiles, fieldNumber: 5)
    }
    if !self.timeProfiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timeProfiles, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeeklyProfileValue, rhs: Proto_WeeklyProfileValue) -> Bool {
    if lhs.singleTimeProfileEntriesActivatable != rhs.singleTimeProfileEntriesActivatable {return false}
    if lhs.maxNumberOfWeeklyTimeProfileSlots != rhs.maxNumberOfWeeklyTimeProfileSlots {return false}
    if lhs.maxNumberOfTimeProfiles != rhs.maxNumberOfTimeProfiles {return false}
    if lhs.currentNumberOfTimeProfileSlots != rhs.currentNumberOfTimeProfileSlots {return false}
    if lhs.currentNumberOfTimeProfiles != rhs.currentNumberOfTimeProfiles {return false}
    if lhs.timeProfiles != rhs.timeProfiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_VVRTimeProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VVRTimeProfile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "identifier", json: "id"),
    2: .same(proto: "hour"),
    3: .unique(proto: "minute", json: "min"),
    4: .unique(proto: "days", json: "day"),
    5: .same(proto: "active"),
    6: .unique(proto: "application_identifier", json: "applicationId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.hour) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.minute) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.days) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.applicationIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.identifier != 0 {
      try visitor.visitSingularInt32Field(value: self.identifier, fieldNumber: 1)
    }
    if self.hour != 0 {
      try visitor.visitSingularInt32Field(value: self.hour, fieldNumber: 2)
    }
    if self.minute != 0 {
      try visitor.visitSingularInt32Field(value: self.minute, fieldNumber: 3)
    }
    if !self.days.isEmpty {
      try visitor.visitPackedEnumField(value: self.days, fieldNumber: 4)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 5)
    }
    if self.applicationIdentifier != 0 {
      try visitor.visitSingularInt32Field(value: self.applicationIdentifier, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_VVRTimeProfile, rhs: Proto_VVRTimeProfile) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.days != rhs.days {return false}
    if lhs.active != rhs.active {return false}
    if lhs.applicationIdentifier != rhs.applicationIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_EcoHistogramValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EcoHistogramValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "eco_histogram_bins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ecoHistogramBins) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ecoHistogramBins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ecoHistogramBins, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_EcoHistogramValue, rhs: Proto_EcoHistogramValue) -> Bool {
    if lhs.ecoHistogramBins != rhs.ecoHistogramBins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_EcoHistogramBin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EcoHistogramBin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interval"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.interval) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.interval != 0 {
      try visitor.visitSingularDoubleField(value: self.interval, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_EcoHistogramBin, rhs: Proto_EcoHistogramBin) -> Bool {
    if lhs.interval != rhs.interval {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SpeedAlertConfigurationValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedAlertConfigurationValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "speed_alert_configurations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.speedAlertConfigurations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.speedAlertConfigurations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.speedAlertConfigurations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SpeedAlertConfigurationValue, rhs: Proto_SpeedAlertConfigurationValue) -> Bool {
    if lhs.speedAlertConfigurations != rhs.speedAlertConfigurations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SpeedAlertConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedAlertConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "end_timestamp_in_s"),
    2: .standard(proto: "threshold_in_kph"),
    3: .standard(proto: "threshold_display_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.endTimestampInS) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.thresholdInKph) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.thresholdDisplayValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.endTimestampInS != 0 {
      try visitor.visitSingularInt64Field(value: self.endTimestampInS, fieldNumber: 1)
    }
    if self.thresholdInKph != 0 {
      try visitor.visitSingularInt32Field(value: self.thresholdInKph, fieldNumber: 2)
    }
    if !self.thresholdDisplayValue.isEmpty {
      try visitor.visitSingularStringField(value: self.thresholdDisplayValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SpeedAlertConfiguration, rhs: Proto_SpeedAlertConfiguration) -> Bool {
    if lhs.endTimestampInS != rhs.endTimestampInS {return false}
    if lhs.thresholdInKph != rhs.thresholdInKph {return false}
    if lhs.thresholdDisplayValue != rhs.thresholdDisplayValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WeeklySettingsHeadUnitValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeeklySettingsHeadUnitValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "weekly_settings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.weeklySettings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.weeklySettings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weeklySettings, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeeklySettingsHeadUnitValue, rhs: Proto_WeeklySettingsHeadUnitValue) -> Bool {
    if lhs.weeklySettings != rhs.weeklySettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WeeklySetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeeklySetting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "day"),
    2: .standard(proto: "minutes_since_midnight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.day) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minutesSinceMidnight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.day != 0 {
      try visitor.visitSingularInt32Field(value: self.day, fieldNumber: 1)
    }
    if self.minutesSinceMidnight != 0 {
      try visitor.visitSingularInt32Field(value: self.minutesSinceMidnight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeeklySetting, rhs: Proto_WeeklySetting) -> Bool {
    if lhs.day != rhs.day {return false}
    if lhs.minutesSinceMidnight != rhs.minutesSinceMidnight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TemperaturePointsValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TemperaturePointsValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "temperature_points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.temperaturePoints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.temperaturePoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.temperaturePoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TemperaturePointsValue, rhs: Proto_TemperaturePointsValue) -> Bool {
    if lhs.temperaturePoints != rhs.temperaturePoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TemperaturePoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TemperaturePoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "zone"),
    2: .same(proto: "temperature"),
    3: .standard(proto: "temperature_display_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.temperature) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.temperatureDisplayValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 1)
    }
    if self.temperature != 0 {
      try visitor.visitSingularDoubleField(value: self.temperature, fieldNumber: 2)
    }
    if !self.temperatureDisplayValue.isEmpty {
      try visitor.visitSingularStringField(value: self.temperatureDisplayValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TemperaturePoint, rhs: Proto_TemperaturePoint) -> Bool {
    if lhs.zone != rhs.zone {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.temperatureDisplayValue != rhs.temperatureDisplayValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WeekdayTariffValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeekdayTariffValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tariffs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tariffs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tariffs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tariffs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeekdayTariffValue, rhs: Proto_WeekdayTariffValue) -> Bool {
    if lhs.tariffs != rhs.tariffs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WeekendTariffValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeekendTariffValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tariffs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tariffs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tariffs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tariffs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeekendTariffValue, rhs: Proto_WeekendTariffValue) -> Bool {
    if lhs.tariffs != rhs.tariffs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Tariff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tariff"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rate"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.rate) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rate != 0 {
      try visitor.visitSingularInt32Field(value: self.rate, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt32Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Tariff, rhs: Proto_Tariff) -> Bool {
    if lhs.rate != rhs.rate {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_StateOfChargeProfileValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StateOfChargeProfileValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "states_of_charge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.statesOfCharge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statesOfCharge.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statesOfCharge, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_StateOfChargeProfileValue, rhs: Proto_StateOfChargeProfileValue) -> Bool {
    if lhs.statesOfCharge != rhs.statesOfCharge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_StateOfCharge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StateOfCharge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_in_s"),
    2: .standard(proto: "state_of_charge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestampInS) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.stateOfCharge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestampInS != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampInS, fieldNumber: 1)
    }
    if self.stateOfCharge != 0 {
      try visitor.visitSingularInt32Field(value: self.stateOfCharge, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_StateOfCharge, rhs: Proto_StateOfCharge) -> Bool {
    if lhs.timestampInS != rhs.timestampInS {return false}
    if lhs.stateOfCharge != rhs.stateOfCharge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_VEPUpdatesByVIN: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VEPUpdatesByVIN"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "sequence_number"),
    1: .same(proto: "updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto_VEPUpdate>.self, value: &self.updates) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto_VEPUpdate>.self, value: self.updates, fieldNumber: 1)
    }
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_VEPUpdatesByVIN, rhs: Proto_VEPUpdatesByVIN) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DebugMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DebugMessage, rhs: Proto_DebugMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_VehicleStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vin"),
    2: .same(proto: "attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vin) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto_VehicleAttributeStatus>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vin.isEmpty {
      try visitor.visitSingularStringField(value: self.vin, fieldNumber: 1)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto_VehicleAttributeStatus>.self, value: self.attributes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_VehicleStatus, rhs: Proto_VehicleStatus) -> Bool {
    if lhs.vin != rhs.vin {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PushMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PushMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "tracking_id"),
    1: .same(proto: "vepUpdate"),
    2: .same(proto: "vepUpdates"),
    3: .same(proto: "debugMessage"),
    9: .standard(proto: "service_status_updates"),
    13: .standard(proto: "service_status_update"),
    10: .standard(proto: "user_data_update"),
    14: .standard(proto: "user_vehicle_auth_changed_update"),
    11: .standard(proto: "user_picture_update"),
    12: .standard(proto: "user_pin_update"),
    15: .standard(proto: "vehicle_updated"),
    16: .standard(proto: "preferred_dealer_change"),
    17: .standard(proto: "apptwin_command_status_updates_by_vin"),
    18: .standard(proto: "apptwin_pending_command_request"),
    19: .standard(proto: "assigned_vehicles"),
    20: .standard(proto: "pers_pin_status_change"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_VEPUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .vepUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .vepUpdate(v)}
      }()
      case 2: try {
        var v: Proto_VEPUpdatesByVIN?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .vepUpdates(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .vepUpdates(v)}
      }()
      case 3: try {
        var v: Proto_DebugMessage?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .debugMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .debugMessage(v)}
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 9: try {
        var v: Proto_ServiceStatusUpdatesByVIN?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .serviceStatusUpdates(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .serviceStatusUpdates(v)}
      }()
      case 10: try {
        var v: Proto_UserDataUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .userDataUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .userDataUpdate(v)}
      }()
      case 11: try {
        var v: Proto_UserPictureUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .userPictureUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .userPictureUpdate(v)}
      }()
      case 12: try {
        var v: Proto_UserPINUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .userPinUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .userPinUpdate(v)}
      }()
      case 13: try {
        var v: Proto_ServiceStatusUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .serviceStatusUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .serviceStatusUpdate(v)}
      }()
      case 14: try {
        var v: Proto_UserVehicleAuthChangedUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .userVehicleAuthChangedUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .userVehicleAuthChangedUpdate(v)}
      }()
      case 15: try {
        var v: Proto_VehicleUpdated?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .vehicleUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .vehicleUpdated(v)}
      }()
      case 16: try {
        var v: Proto_PreferredDealerChange?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .preferredDealerChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .preferredDealerChange(v)}
      }()
      case 17: try {
        var v: Proto_AppTwinCommandStatusUpdatesByVIN?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .apptwinCommandStatusUpdatesByVin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .apptwinCommandStatusUpdatesByVin(v)}
      }()
      case 18: try {
        var v: Proto_AppTwinPendingCommandsRequest?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .apptwinPendingCommandRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .apptwinPendingCommandRequest(v)}
      }()
      case 19: try {
        var v: Proto_AssignedVehicles?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .assignedVehicles(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .assignedVehicles(v)}
      }()
      case 20: try {
        var v: Proto_PersPinStatusChangeUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .persPinStatusChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .persPinStatusChange(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.msg {
    case .vepUpdate?: try {
      guard case .vepUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .vepUpdates?: try {
      guard case .vepUpdates(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .debugMessage?: try {
      guard case .debugMessage(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    default: break
    }
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 5)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.msg {
    case .serviceStatusUpdates?: try {
      guard case .serviceStatusUpdates(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .userDataUpdate?: try {
      guard case .userDataUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .userPictureUpdate?: try {
      guard case .userPictureUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .userPinUpdate?: try {
      guard case .userPinUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .serviceStatusUpdate?: try {
      guard case .serviceStatusUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .userVehicleAuthChangedUpdate?: try {
      guard case .userVehicleAuthChangedUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .vehicleUpdated?: try {
      guard case .vehicleUpdated(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .preferredDealerChange?: try {
      guard case .preferredDealerChange(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .apptwinCommandStatusUpdatesByVin?: try {
      guard case .apptwinCommandStatusUpdatesByVin(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .apptwinPendingCommandRequest?: try {
      guard case .apptwinPendingCommandRequest(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .assignedVehicles?: try {
      guard case .assignedVehicles(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .persPinStatusChange?: try {
      guard case .persPinStatusChange(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_PushMessage, rhs: Proto_PushMessage) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TrackingEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackingEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .same(proto: "timestamp"),
    3: .standard(proto: "event_type"),
    4: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.eventType) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto_PayloadValue>.self, value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if !self.eventType.isEmpty {
      try visitor.visitSingularStringField(value: self.eventType, fieldNumber: 3)
    }
    if !self.payload.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto_PayloadValue>.self, value: self.payload, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TrackingEvent, rhs: Proto_TrackingEvent) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.eventType != rhs.eventType {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PayloadValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayloadValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "string_value"),
    2: .standard(proto: "int_value"),
    3: .standard(proto: "bool_value"),
    4: .standard(proto: "double_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.msg != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.msg = .stringValue(v)}
      }()
      case 2: try {
        if self.msg != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.msg = .intValue(v)}
      }()
      case 3: try {
        if self.msg != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.msg = .boolValue(v)}
      }()
      case 4: try {
        if self.msg != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.msg = .doubleValue(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.msg {
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .intValue?: try {
      guard case .intValue(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_PayloadValue, rhs: Proto_PayloadValue) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AcknowledgeVEPRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeVEPRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeVEPRequest, rhs: Proto_AcknowledgeVEPRequest) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AcknowledgeVEPUpdatesByVIN: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeVEPUpdatesByVIN"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeVEPUpdatesByVIN, rhs: Proto_AcknowledgeVEPUpdatesByVIN) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ConfigurePingInterval: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigurePingInterval"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ping_time_millis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pingTimeMillis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pingTimeMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.pingTimeMillis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ConfigurePingInterval, rhs: Proto_ConfigurePingInterval) -> Bool {
    if lhs.pingTimeMillis != rhs.pingTimeMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AcknowledgeVehicleUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeVehicleUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeVehicleUpdated, rhs: Proto_AcknowledgeVehicleUpdated) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AcknowledgePreferredDealerChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgePreferredDealerChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgePreferredDealerChange, rhs: Proto_AcknowledgePreferredDealerChange) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_VehicleUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    2: .standard(proto: "ciam_id"),
    3: .same(proto: "vin"),
    10: .standard(proto: "emit_timestamp_in_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ciamID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.vin) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestampInMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    if !self.ciamID.isEmpty {
      try visitor.visitSingularStringField(value: self.ciamID, fieldNumber: 2)
    }
    if !self.vin.isEmpty {
      try visitor.visitSingularStringField(value: self.vin, fieldNumber: 3)
    }
    if self.emitTimestampInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestampInMs, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_VehicleUpdated, rhs: Proto_VehicleUpdated) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.ciamID != rhs.ciamID {return false}
    if lhs.vin != rhs.vin {return false}
    if lhs.emitTimestampInMs != rhs.emitTimestampInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PreferredDealerChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreferredDealerChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    2: .standard(proto: "ciam_id"),
    3: .same(proto: "vin"),
    10: .standard(proto: "emit_timestamp_in_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ciamID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.vin) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestampInMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    if !self.ciamID.isEmpty {
      try visitor.visitSingularStringField(value: self.ciamID, fieldNumber: 2)
    }
    if !self.vin.isEmpty {
      try visitor.visitSingularStringField(value: self.vin, fieldNumber: 3)
    }
    if self.emitTimestampInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestampInMs, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_PreferredDealerChange, rhs: Proto_PreferredDealerChange) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.ciamID != rhs.ciamID {return false}
    if lhs.vin != rhs.vin {return false}
    if lhs.emitTimestampInMs != rhs.emitTimestampInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
