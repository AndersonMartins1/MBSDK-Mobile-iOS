// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vehicle-commands.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Proto_Door: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// the lowercase versions are for json (de)serialization purposes only. The upper case version should be the preferred
  /// enum values to be used in code.
  /// These definitions need to come before upper case versions
  case unknownDoor // = 0
  case frontleft // = 1
  case frontright // = 2
  case rearleft // = 3
  case rearright // = 4
  case trunk // = 5
  case fuelflap // = 6
  case chargeflap // = 7
  case chargecoupler // = 8
  static let frontLeft = frontleft
  static let frontRight = frontright
  static let rearLeft = rearleft
  static let rearRight = rearright
  static let fuelFlap = fuelflap
  static let chargeFlap = chargeflap
  static let chargeCoupler = chargecoupler
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownDoor
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDoor
    case 1: self = .frontleft
    case 2: self = .frontright
    case 3: self = .rearleft
    case 4: self = .rearright
    case 5: self = .trunk
    case 6: self = .fuelflap
    case 7: self = .chargeflap
    case 8: self = .chargecoupler
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownDoor: return 0
    case .frontleft: return 1
    case .frontright: return 2
    case .rearleft: return 3
    case .rearright: return 4
    case .trunk: return 5
    case .fuelflap: return 6
    case .chargeflap: return 7
    case .chargecoupler: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Door: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_Door] = [
    .unknownDoor,
    .frontleft,
    .frontright,
    .rearleft,
    .rearright,
    .trunk,
    .fuelflap,
    .chargeflap,
    .chargecoupler,
  ]
}

#endif  // swift(>=4.2)

enum Proto_ZEVPreconditioningType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// the lowercase versions are for json parsing purposes only. The upper case version should be the preferred
  /// enum values to be used in code.
  /// These definitions need to come before upper case versions
  case unknownZevPreconditioningCommandType // = 0
  case immediate // = 1
  case departure // = 2
  case now // = 3
  case departureWeekly // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownZevPreconditioningCommandType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownZevPreconditioningCommandType
    case 1: self = .immediate
    case 2: self = .departure
    case 3: self = .now
    case 4: self = .departureWeekly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownZevPreconditioningCommandType: return 0
    case .immediate: return 1
    case .departure: return 2
    case .now: return 3
    case .departureWeekly: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_ZEVPreconditioningType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ZEVPreconditioningType] = [
    .unknownZevPreconditioningCommandType,
    .immediate,
    .departure,
    .now,
    .departureWeekly,
  ]
}

#endif  // swift(>=4.2)

enum Proto_TimeProfileDay: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// the short versions are for json (en)coding purposes only. The upper case version should be the preferred
  /// enum values to be used in code.
  /// These definitions need to come before upper case versions
  case mo // = 0
  case tu // = 1
  case we // = 2
  case th // = 3
  case fr // = 4
  case sa // = 5
  case su // = 6
  static let monday = mo
  static let tuesday = tu
  static let wednesday = we
  static let thursday = th
  static let friday = fr
  static let saturday = sa
  static let sunday = su
  case UNRECOGNIZED(Int)

  init() {
    self = .mo
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mo
    case 1: self = .tu
    case 2: self = .we
    case 3: self = .th
    case 4: self = .fr
    case 5: self = .sa
    case 6: self = .su
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .mo: return 0
    case .tu: return 1
    case .we: return 2
    case .th: return 3
    case .fr: return 4
    case .sa: return 5
    case .su: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_TimeProfileDay: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_TimeProfileDay] = [
    .mo,
    .tu,
    .we,
    .th,
    .fr,
    .sa,
    .su,
  ]
}

#endif  // swift(>=4.2)

enum Proto_DriveType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownDriveType // = 0
  case pickUp // = 1
  case dropOff // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownDriveType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDriveType
    case 1: self = .pickUp
    case 2: self = .dropOff
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownDriveType: return 0
    case .pickUp: return 1
    case .dropOff: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_DriveType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_DriveType] = [
    .unknownDriveType,
    .pickUp,
    .dropOff,
  ]
}

#endif  // swift(>=4.2)

/// Acknowledge the CommandRequest reached the apptwin actor
/// Websocket <- Apptwin
struct Proto_AcknowledgeCommandRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// After the command was issued at VVA based on this
/// command request the call will get a command request
/// correlation message which matches the request id
/// with the process id.
/// Sending direction: App - BFF -> AppTwin
struct Proto_CommandRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vin: String = String()

  /// Set this id to correlate a CommandStatus
  /// with this command request.
  var requestID: String = String()

  var backend: Proto_CommandRequest.Backend = .vva

  var command: Proto_CommandRequest.OneOf_Command? = nil

  var auxheatStart: Proto_AuxheatStart {
    get {
      if case .auxheatStart(let v)? = command {return v}
      return Proto_AuxheatStart()
    }
    set {command = .auxheatStart(newValue)}
  }

  var auxheatStop: Proto_AuxheatStop {
    get {
      if case .auxheatStop(let v)? = command {return v}
      return Proto_AuxheatStop()
    }
    set {command = .auxheatStop(newValue)}
  }

  var auxheatConfigure: Proto_AuxheatConfigure {
    get {
      if case .auxheatConfigure(let v)? = command {return v}
      return Proto_AuxheatConfigure()
    }
    set {command = .auxheatConfigure(newValue)}
  }

  var doorsLock: Proto_DoorsLock {
    get {
      if case .doorsLock(let v)? = command {return v}
      return Proto_DoorsLock()
    }
    set {command = .doorsLock(newValue)}
  }

  var doorsUnlock: Proto_DoorsUnlock {
    get {
      if case .doorsUnlock(let v)? = command {return v}
      return Proto_DoorsUnlock()
    }
    set {command = .doorsUnlock(newValue)}
  }

  var sunroofOpen: Proto_SunroofOpen {
    get {
      if case .sunroofOpen(let v)? = command {return v}
      return Proto_SunroofOpen()
    }
    set {command = .sunroofOpen(newValue)}
  }

  var sunroofClose: Proto_SunroofClose {
    get {
      if case .sunroofClose(let v)? = command {return v}
      return Proto_SunroofClose()
    }
    set {command = .sunroofClose(newValue)}
  }

  var sunroofLift: Proto_SunroofLift {
    get {
      if case .sunroofLift(let v)? = command {return v}
      return Proto_SunroofLift()
    }
    set {command = .sunroofLift(newValue)}
  }

  var sunroofMove: Proto_SunroofMove {
    get {
      if case .sunroofMove(let v)? = command {return v}
      return Proto_SunroofMove()
    }
    set {command = .sunroofMove(newValue)}
  }

  var windowsOpen: Proto_WindowsOpen {
    get {
      if case .windowsOpen(let v)? = command {return v}
      return Proto_WindowsOpen()
    }
    set {command = .windowsOpen(newValue)}
  }

  var windowsClose: Proto_WindowsClose {
    get {
      if case .windowsClose(let v)? = command {return v}
      return Proto_WindowsClose()
    }
    set {command = .windowsClose(newValue)}
  }

  var windowsVentilate: Proto_WindowsVentilate {
    get {
      if case .windowsVentilate(let v)? = command {return v}
      return Proto_WindowsVentilate()
    }
    set {command = .windowsVentilate(newValue)}
  }

  var windowsMove: Proto_WindowsMove {
    get {
      if case .windowsMove(let v)? = command {return v}
      return Proto_WindowsMove()
    }
    set {command = .windowsMove(newValue)}
  }

  var engineStart: Proto_EngineStart {
    get {
      if case .engineStart(let v)? = command {return v}
      return Proto_EngineStart()
    }
    set {command = .engineStart(newValue)}
  }

  var engineStop: Proto_EngineStop {
    get {
      if case .engineStop(let v)? = command {return v}
      return Proto_EngineStop()
    }
    set {command = .engineStop(newValue)}
  }

  var zevPreconditioningStart: Proto_ZEVPreconditioningStart {
    get {
      if case .zevPreconditioningStart(let v)? = command {return v}
      return Proto_ZEVPreconditioningStart()
    }
    set {command = .zevPreconditioningStart(newValue)}
  }

  var zevPreconditioningStop: Proto_ZEVPreconditioningStop {
    get {
      if case .zevPreconditioningStop(let v)? = command {return v}
      return Proto_ZEVPreconditioningStop()
    }
    set {command = .zevPreconditioningStop(newValue)}
  }

  var zevPreconditionConfigure: Proto_ZEVPreconditioningConfigure {
    get {
      if case .zevPreconditionConfigure(let v)? = command {return v}
      return Proto_ZEVPreconditioningConfigure()
    }
    set {command = .zevPreconditionConfigure(newValue)}
  }

  var zevPreconditionConfigureSeats: Proto_ZEVPreconditioningConfigureSeats {
    get {
      if case .zevPreconditionConfigureSeats(let v)? = command {return v}
      return Proto_ZEVPreconditioningConfigureSeats()
    }
    set {command = .zevPreconditionConfigureSeats(newValue)}
  }

  var speedalertStart: Proto_SpeedalertStart {
    get {
      if case .speedalertStart(let v)? = command {return v}
      return Proto_SpeedalertStart()
    }
    set {command = .speedalertStart(newValue)}
  }

  var speedalertStop: Proto_SpeedalertStop {
    get {
      if case .speedalertStop(let v)? = command {return v}
      return Proto_SpeedalertStop()
    }
    set {command = .speedalertStop(newValue)}
  }

  var batteryChargeProgram: Proto_BatteryChargeProgramConfigure {
    get {
      if case .batteryChargeProgram(let v)? = command {return v}
      return Proto_BatteryChargeProgramConfigure()
    }
    set {command = .batteryChargeProgram(newValue)}
  }

  var batteryMaxSoc: Proto_BatteryMaxSocConfigure {
    get {
      if case .batteryMaxSoc(let v)? = command {return v}
      return Proto_BatteryMaxSocConfigure()
    }
    set {command = .batteryMaxSoc(newValue)}
  }

  var chargeProgramConfigure: Proto_ChargeProgramConfigure {
    get {
      if case .chargeProgramConfigure(let v)? = command {return v}
      return Proto_ChargeProgramConfigure()
    }
    set {command = .chargeProgramConfigure(newValue)}
  }

  var chargeControlConfigure: Proto_ChargeControlConfigure {
    get {
      if case .chargeControlConfigure(let v)? = command {return v}
      return Proto_ChargeControlConfigure()
    }
    set {command = .chargeControlConfigure(newValue)}
  }

  var chargeOptConfigure: Proto_ChargeOptConfigure {
    get {
      if case .chargeOptConfigure(let v)? = command {return v}
      return Proto_ChargeOptConfigure()
    }
    set {command = .chargeOptConfigure(newValue)}
  }

  var chargeOptStart: Proto_ChargeOptStart {
    get {
      if case .chargeOptStart(let v)? = command {return v}
      return Proto_ChargeOptStart()
    }
    set {command = .chargeOptStart(newValue)}
  }

  var chargeOptStop: Proto_ChargeOptStop {
    get {
      if case .chargeOptStop(let v)? = command {return v}
      return Proto_ChargeOptStop()
    }
    set {command = .chargeOptStop(newValue)}
  }

  var temperatureConfigure: Proto_TemperatureConfigure {
    get {
      if case .temperatureConfigure(let v)? = command {return v}
      return Proto_TemperatureConfigure()
    }
    set {command = .temperatureConfigure(newValue)}
  }

  var weekProfileConfigure: Proto_WeekProfileConfigure {
    get {
      if case .weekProfileConfigure(let v)? = command {return v}
      return Proto_WeekProfileConfigure()
    }
    set {command = .weekProfileConfigure(newValue)}
  }

  var weekProfileConfigureV2: Proto_WeekProfileConfigureV2 {
    get {
      if case .weekProfileConfigureV2(let v)? = command {return v}
      return Proto_WeekProfileConfigureV2()
    }
    set {command = .weekProfileConfigureV2(newValue)}
  }

  var sigposStart: Proto_SigPosStart {
    get {
      if case .sigposStart(let v)? = command {return v}
      return Proto_SigPosStart()
    }
    set {command = .sigposStart(newValue)}
  }

  var theftalarmConfirmDamagedetection: Proto_TheftalarmConfirmDamagedetection {
    get {
      if case .theftalarmConfirmDamagedetection(let v)? = command {return v}
      return Proto_TheftalarmConfirmDamagedetection()
    }
    set {command = .theftalarmConfirmDamagedetection(newValue)}
  }

  var theftalarmDeselectDamagedetection: Proto_TheftalarmDeselectDamagedetection {
    get {
      if case .theftalarmDeselectDamagedetection(let v)? = command {return v}
      return Proto_TheftalarmDeselectDamagedetection()
    }
    set {command = .theftalarmDeselectDamagedetection(newValue)}
  }

  var theftalarmDeselectInterior: Proto_TheftalarmDeselectInterior {
    get {
      if case .theftalarmDeselectInterior(let v)? = command {return v}
      return Proto_TheftalarmDeselectInterior()
    }
    set {command = .theftalarmDeselectInterior(newValue)}
  }

  var theftalarmDeselectTow: Proto_TheftalarmDeselectTow {
    get {
      if case .theftalarmDeselectTow(let v)? = command {return v}
      return Proto_TheftalarmDeselectTow()
    }
    set {command = .theftalarmDeselectTow(newValue)}
  }

  var theftalarmSelectDamagedetection: Proto_TheftalarmSelectDamagedetection {
    get {
      if case .theftalarmSelectDamagedetection(let v)? = command {return v}
      return Proto_TheftalarmSelectDamagedetection()
    }
    set {command = .theftalarmSelectDamagedetection(newValue)}
  }

  var theftalarmSelectInterior: Proto_TheftalarmSelectInterior {
    get {
      if case .theftalarmSelectInterior(let v)? = command {return v}
      return Proto_TheftalarmSelectInterior()
    }
    set {command = .theftalarmSelectInterior(newValue)}
  }

  var theftalarmSelectTow: Proto_TheftalarmSelectTow {
    get {
      if case .theftalarmSelectTow(let v)? = command {return v}
      return Proto_TheftalarmSelectTow()
    }
    set {command = .theftalarmSelectTow(newValue)}
  }

  var theftalarmStart: Proto_TheftalarmStart {
    get {
      if case .theftalarmStart(let v)? = command {return v}
      return Proto_TheftalarmStart()
    }
    set {command = .theftalarmStart(newValue)}
  }

  var theftalarmStop: Proto_TheftalarmStop {
    get {
      if case .theftalarmStop(let v)? = command {return v}
      return Proto_TheftalarmStop()
    }
    set {command = .theftalarmStop(newValue)}
  }

  var automaticValetParkingActivate: Proto_AutomaticValetParkingActivate {
    get {
      if case .automaticValetParkingActivate(let v)? = command {return v}
      return Proto_AutomaticValetParkingActivate()
    }
    set {command = .automaticValetParkingActivate(newValue)}
  }

  var chargeFlapUnlock: Proto_ChargeFlapUnlock {
    get {
      if case .chargeFlapUnlock(let v)? = command {return v}
      return Proto_ChargeFlapUnlock()
    }
    set {command = .chargeFlapUnlock(newValue)}
  }

  var chargeCouplerUnlock: Proto_ChargeCouplerUnlock {
    get {
      if case .chargeCouplerUnlock(let v)? = command {return v}
      return Proto_ChargeCouplerUnlock()
    }
    set {command = .chargeCouplerUnlock(newValue)}
  }

  var deactivateVehicleKeys: Proto_DeactivateVehicleKeys {
    get {
      if case .deactivateVehicleKeys(let v)? = command {return v}
      return Proto_DeactivateVehicleKeys()
    }
    set {command = .deactivateVehicleKeys(newValue)}
  }

  var activateVehicleKeys: Proto_ActivateVehicleKeys {
    get {
      if case .activateVehicleKeys(let v)? = command {return v}
      return Proto_ActivateVehicleKeys()
    }
    set {command = .activateVehicleKeys(newValue)}
  }

  var chargingBreakClocktimerConfigure: Proto_ChargingBreakClocktimerConfigure {
    get {
      if case .chargingBreakClocktimerConfigure(let v)? = command {return v}
      return Proto_ChargingBreakClocktimerConfigure()
    }
    set {command = .chargingBreakClocktimerConfigure(newValue)}
  }

  var teenageDrivingModeActivate: Proto_TeenageDrivingModeActivate {
    get {
      if case .teenageDrivingModeActivate(let v)? = command {return v}
      return Proto_TeenageDrivingModeActivate()
    }
    set {command = .teenageDrivingModeActivate(newValue)}
  }

  var teenageDrivingModeDeactivate: Proto_TeenageDrivingModeDeactivate {
    get {
      if case .teenageDrivingModeDeactivate(let v)? = command {return v}
      return Proto_TeenageDrivingModeDeactivate()
    }
    set {command = .teenageDrivingModeDeactivate(newValue)}
  }

  var valetDrivingModeActivate: Proto_ValetDrivingModeActivate {
    get {
      if case .valetDrivingModeActivate(let v)? = command {return v}
      return Proto_ValetDrivingModeActivate()
    }
    set {command = .valetDrivingModeActivate(newValue)}
  }

  var valetDrivingModeDeactivate: Proto_ValetDrivingModeDeactivate {
    get {
      if case .valetDrivingModeDeactivate(let v)? = command {return v}
      return Proto_ValetDrivingModeDeactivate()
    }
    set {command = .valetDrivingModeDeactivate(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Command: Equatable {
    case auxheatStart(Proto_AuxheatStart)
    case auxheatStop(Proto_AuxheatStop)
    case auxheatConfigure(Proto_AuxheatConfigure)
    case doorsLock(Proto_DoorsLock)
    case doorsUnlock(Proto_DoorsUnlock)
    case sunroofOpen(Proto_SunroofOpen)
    case sunroofClose(Proto_SunroofClose)
    case sunroofLift(Proto_SunroofLift)
    case sunroofMove(Proto_SunroofMove)
    case windowsOpen(Proto_WindowsOpen)
    case windowsClose(Proto_WindowsClose)
    case windowsVentilate(Proto_WindowsVentilate)
    case windowsMove(Proto_WindowsMove)
    case engineStart(Proto_EngineStart)
    case engineStop(Proto_EngineStop)
    case zevPreconditioningStart(Proto_ZEVPreconditioningStart)
    case zevPreconditioningStop(Proto_ZEVPreconditioningStop)
    case zevPreconditionConfigure(Proto_ZEVPreconditioningConfigure)
    case zevPreconditionConfigureSeats(Proto_ZEVPreconditioningConfigureSeats)
    case speedalertStart(Proto_SpeedalertStart)
    case speedalertStop(Proto_SpeedalertStop)
    case batteryChargeProgram(Proto_BatteryChargeProgramConfigure)
    case batteryMaxSoc(Proto_BatteryMaxSocConfigure)
    case chargeProgramConfigure(Proto_ChargeProgramConfigure)
    case chargeControlConfigure(Proto_ChargeControlConfigure)
    case chargeOptConfigure(Proto_ChargeOptConfigure)
    case chargeOptStart(Proto_ChargeOptStart)
    case chargeOptStop(Proto_ChargeOptStop)
    case temperatureConfigure(Proto_TemperatureConfigure)
    case weekProfileConfigure(Proto_WeekProfileConfigure)
    case weekProfileConfigureV2(Proto_WeekProfileConfigureV2)
    case sigposStart(Proto_SigPosStart)
    case theftalarmConfirmDamagedetection(Proto_TheftalarmConfirmDamagedetection)
    case theftalarmDeselectDamagedetection(Proto_TheftalarmDeselectDamagedetection)
    case theftalarmDeselectInterior(Proto_TheftalarmDeselectInterior)
    case theftalarmDeselectTow(Proto_TheftalarmDeselectTow)
    case theftalarmSelectDamagedetection(Proto_TheftalarmSelectDamagedetection)
    case theftalarmSelectInterior(Proto_TheftalarmSelectInterior)
    case theftalarmSelectTow(Proto_TheftalarmSelectTow)
    case theftalarmStart(Proto_TheftalarmStart)
    case theftalarmStop(Proto_TheftalarmStop)
    case automaticValetParkingActivate(Proto_AutomaticValetParkingActivate)
    case chargeFlapUnlock(Proto_ChargeFlapUnlock)
    case chargeCouplerUnlock(Proto_ChargeCouplerUnlock)
    case deactivateVehicleKeys(Proto_DeactivateVehicleKeys)
    case activateVehicleKeys(Proto_ActivateVehicleKeys)
    case chargingBreakClocktimerConfigure(Proto_ChargingBreakClocktimerConfigure)
    case teenageDrivingModeActivate(Proto_TeenageDrivingModeActivate)
    case teenageDrivingModeDeactivate(Proto_TeenageDrivingModeDeactivate)
    case valetDrivingModeActivate(Proto_ValetDrivingModeActivate)
    case valetDrivingModeDeactivate(Proto_ValetDrivingModeDeactivate)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_CommandRequest.OneOf_Command, rhs: Proto_CommandRequest.OneOf_Command) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.auxheatStart, .auxheatStart): return {
        guard case .auxheatStart(let l) = lhs, case .auxheatStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.auxheatStop, .auxheatStop): return {
        guard case .auxheatStop(let l) = lhs, case .auxheatStop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.auxheatConfigure, .auxheatConfigure): return {
        guard case .auxheatConfigure(let l) = lhs, case .auxheatConfigure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doorsLock, .doorsLock): return {
        guard case .doorsLock(let l) = lhs, case .doorsLock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doorsUnlock, .doorsUnlock): return {
        guard case .doorsUnlock(let l) = lhs, case .doorsUnlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sunroofOpen, .sunroofOpen): return {
        guard case .sunroofOpen(let l) = lhs, case .sunroofOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sunroofClose, .sunroofClose): return {
        guard case .sunroofClose(let l) = lhs, case .sunroofClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sunroofLift, .sunroofLift): return {
        guard case .sunroofLift(let l) = lhs, case .sunroofLift(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sunroofMove, .sunroofMove): return {
        guard case .sunroofMove(let l) = lhs, case .sunroofMove(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowsOpen, .windowsOpen): return {
        guard case .windowsOpen(let l) = lhs, case .windowsOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowsClose, .windowsClose): return {
        guard case .windowsClose(let l) = lhs, case .windowsClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowsVentilate, .windowsVentilate): return {
        guard case .windowsVentilate(let l) = lhs, case .windowsVentilate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowsMove, .windowsMove): return {
        guard case .windowsMove(let l) = lhs, case .windowsMove(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.engineStart, .engineStart): return {
        guard case .engineStart(let l) = lhs, case .engineStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.engineStop, .engineStop): return {
        guard case .engineStop(let l) = lhs, case .engineStop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.zevPreconditioningStart, .zevPreconditioningStart): return {
        guard case .zevPreconditioningStart(let l) = lhs, case .zevPreconditioningStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.zevPreconditioningStop, .zevPreconditioningStop): return {
        guard case .zevPreconditioningStop(let l) = lhs, case .zevPreconditioningStop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.zevPreconditionConfigure, .zevPreconditionConfigure): return {
        guard case .zevPreconditionConfigure(let l) = lhs, case .zevPreconditionConfigure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.zevPreconditionConfigureSeats, .zevPreconditionConfigureSeats): return {
        guard case .zevPreconditionConfigureSeats(let l) = lhs, case .zevPreconditionConfigureSeats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.speedalertStart, .speedalertStart): return {
        guard case .speedalertStart(let l) = lhs, case .speedalertStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.speedalertStop, .speedalertStop): return {
        guard case .speedalertStop(let l) = lhs, case .speedalertStop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.batteryChargeProgram, .batteryChargeProgram): return {
        guard case .batteryChargeProgram(let l) = lhs, case .batteryChargeProgram(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.batteryMaxSoc, .batteryMaxSoc): return {
        guard case .batteryMaxSoc(let l) = lhs, case .batteryMaxSoc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargeProgramConfigure, .chargeProgramConfigure): return {
        guard case .chargeProgramConfigure(let l) = lhs, case .chargeProgramConfigure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargeControlConfigure, .chargeControlConfigure): return {
        guard case .chargeControlConfigure(let l) = lhs, case .chargeControlConfigure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargeOptConfigure, .chargeOptConfigure): return {
        guard case .chargeOptConfigure(let l) = lhs, case .chargeOptConfigure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargeOptStart, .chargeOptStart): return {
        guard case .chargeOptStart(let l) = lhs, case .chargeOptStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargeOptStop, .chargeOptStop): return {
        guard case .chargeOptStop(let l) = lhs, case .chargeOptStop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.temperatureConfigure, .temperatureConfigure): return {
        guard case .temperatureConfigure(let l) = lhs, case .temperatureConfigure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.weekProfileConfigure, .weekProfileConfigure): return {
        guard case .weekProfileConfigure(let l) = lhs, case .weekProfileConfigure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.weekProfileConfigureV2, .weekProfileConfigureV2): return {
        guard case .weekProfileConfigureV2(let l) = lhs, case .weekProfileConfigureV2(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sigposStart, .sigposStart): return {
        guard case .sigposStart(let l) = lhs, case .sigposStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.theftalarmConfirmDamagedetection, .theftalarmConfirmDamagedetection): return {
        guard case .theftalarmConfirmDamagedetection(let l) = lhs, case .theftalarmConfirmDamagedetection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.theftalarmDeselectDamagedetection, .theftalarmDeselectDamagedetection): return {
        guard case .theftalarmDeselectDamagedetection(let l) = lhs, case .theftalarmDeselectDamagedetection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.theftalarmDeselectInterior, .theftalarmDeselectInterior): return {
        guard case .theftalarmDeselectInterior(let l) = lhs, case .theftalarmDeselectInterior(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.theftalarmDeselectTow, .theftalarmDeselectTow): return {
        guard case .theftalarmDeselectTow(let l) = lhs, case .theftalarmDeselectTow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.theftalarmSelectDamagedetection, .theftalarmSelectDamagedetection): return {
        guard case .theftalarmSelectDamagedetection(let l) = lhs, case .theftalarmSelectDamagedetection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.theftalarmSelectInterior, .theftalarmSelectInterior): return {
        guard case .theftalarmSelectInterior(let l) = lhs, case .theftalarmSelectInterior(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.theftalarmSelectTow, .theftalarmSelectTow): return {
        guard case .theftalarmSelectTow(let l) = lhs, case .theftalarmSelectTow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.theftalarmStart, .theftalarmStart): return {
        guard case .theftalarmStart(let l) = lhs, case .theftalarmStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.theftalarmStop, .theftalarmStop): return {
        guard case .theftalarmStop(let l) = lhs, case .theftalarmStop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.automaticValetParkingActivate, .automaticValetParkingActivate): return {
        guard case .automaticValetParkingActivate(let l) = lhs, case .automaticValetParkingActivate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargeFlapUnlock, .chargeFlapUnlock): return {
        guard case .chargeFlapUnlock(let l) = lhs, case .chargeFlapUnlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargeCouplerUnlock, .chargeCouplerUnlock): return {
        guard case .chargeCouplerUnlock(let l) = lhs, case .chargeCouplerUnlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deactivateVehicleKeys, .deactivateVehicleKeys): return {
        guard case .deactivateVehicleKeys(let l) = lhs, case .deactivateVehicleKeys(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.activateVehicleKeys, .activateVehicleKeys): return {
        guard case .activateVehicleKeys(let l) = lhs, case .activateVehicleKeys(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargingBreakClocktimerConfigure, .chargingBreakClocktimerConfigure): return {
        guard case .chargingBreakClocktimerConfigure(let l) = lhs, case .chargingBreakClocktimerConfigure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.teenageDrivingModeActivate, .teenageDrivingModeActivate): return {
        guard case .teenageDrivingModeActivate(let l) = lhs, case .teenageDrivingModeActivate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.teenageDrivingModeDeactivate, .teenageDrivingModeDeactivate): return {
        guard case .teenageDrivingModeDeactivate(let l) = lhs, case .teenageDrivingModeDeactivate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.valetDrivingModeActivate, .valetDrivingModeActivate): return {
        guard case .valetDrivingModeActivate(let l) = lhs, case .valetDrivingModeActivate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.valetDrivingModeDeactivate, .valetDrivingModeDeactivate): return {
        guard case .valetDrivingModeDeactivate(let l) = lhs, case .valetDrivingModeDeactivate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Temporary backend switch field. Will be removed as soon as all commands are migrated to the VehicleAPI
  /// This field only needs to be set if the command is supported by both API from our backend. If this field is removed
  /// don't forget to set the field 36 to reserved.
  enum Backend: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// default value
    case vva // = 0
    case vehicleApi // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .vva
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .vva
      case 1: self = .vehicleApi
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .vva: return 0
      case .vehicleApi: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_CommandRequest.Backend: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_CommandRequest.Backend] = [
    .vva,
    .vehicleApi,
  ]
}

#endif  // swift(>=4.2)

struct Proto_DeactivateVehicleKeys {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var expirationUnix: Int64 = 0

  var expirationSeconds: String = String()

  var expirationMilliseconds: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ActivateVehicleKeys {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var expirationUnix: Int64 = 0

  var expirationSeconds: String = String()

  var expirationMilliseconds: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AuxheatStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AuxheatStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AuxheatConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeSelection: Proto_AuxheatConfigure.Selection = .noSelection

  /// Minutes from midnight.
  var time1: Int32 = 0

  /// Minutes from midnight.
  var time2: Int32 = 0

  /// Minutes from midnight.
  var time3: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Selection: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case noSelection // = 0
    case time1 // = 1
    case time2 // = 2
    case time3 // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .noSelection
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noSelection
      case 1: self = .time1
      case 2: self = .time2
      case 3: self = .time3
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .noSelection: return 0
      case .time1: return 1
      case .time2: return 2
      case .time3: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_AuxheatConfigure.Selection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_AuxheatConfigure.Selection] = [
    .noSelection,
    .time1,
    .time2,
    .time3,
  ]
}

#endif  // swift(>=4.2)

struct Proto_DoorsLock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// doors / flaps to unlock (only supported by TCU type RAMSES)
  /// leave empty to target all doors
  var doors: [Proto_Door] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_DoorsUnlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  /// doors / flaps to unlock (only supported by TCU type RAMSES)
  /// leave empty to target all doors
  var doors: [Proto_Door] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_EngineStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_EngineStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SunroofOpen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SunroofClose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SunroofLift {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SunroofMove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var sunroof: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _sunroof ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_sunroof = newValue}
  }
  /// Returns true if `sunroof` has been explicitly set.
  var hasSunroof: Bool {return self._sunroof != nil}
  /// Clears the value of `sunroof`. Subsequent reads from it will return its default value.
  mutating func clearSunroof() {self._sunroof = nil}

  var sunroofBlindFront: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _sunroofBlindFront ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_sunroofBlindFront = newValue}
  }
  /// Returns true if `sunroofBlindFront` has been explicitly set.
  var hasSunroofBlindFront: Bool {return self._sunroofBlindFront != nil}
  /// Clears the value of `sunroofBlindFront`. Subsequent reads from it will return its default value.
  mutating func clearSunroofBlindFront() {self._sunroofBlindFront = nil}

  var sunroofBlindRear: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _sunroofBlindRear ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_sunroofBlindRear = newValue}
  }
  /// Returns true if `sunroofBlindRear` has been explicitly set.
  var hasSunroofBlindRear: Bool {return self._sunroofBlindRear != nil}
  /// Clears the value of `sunroofBlindRear`. Subsequent reads from it will return its default value.
  mutating func clearSunroofBlindRear() {self._sunroofBlindRear = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sunroof: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _sunroofBlindFront: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _sunroofBlindRear: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

struct Proto_WindowsOpen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WindowsClose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WindowsVentilate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WindowsMove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var frontLeft: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _frontLeft ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_frontLeft = newValue}
  }
  /// Returns true if `frontLeft` has been explicitly set.
  var hasFrontLeft: Bool {return self._frontLeft != nil}
  /// Clears the value of `frontLeft`. Subsequent reads from it will return its default value.
  mutating func clearFrontLeft() {self._frontLeft = nil}

  var frontRight: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _frontRight ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_frontRight = newValue}
  }
  /// Returns true if `frontRight` has been explicitly set.
  var hasFrontRight: Bool {return self._frontRight != nil}
  /// Clears the value of `frontRight`. Subsequent reads from it will return its default value.
  mutating func clearFrontRight() {self._frontRight = nil}

  var rearBlind: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _rearBlind ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_rearBlind = newValue}
  }
  /// Returns true if `rearBlind` has been explicitly set.
  var hasRearBlind: Bool {return self._rearBlind != nil}
  /// Clears the value of `rearBlind`. Subsequent reads from it will return its default value.
  mutating func clearRearBlind() {self._rearBlind = nil}

  var rearLeft: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _rearLeft ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_rearLeft = newValue}
  }
  /// Returns true if `rearLeft` has been explicitly set.
  var hasRearLeft: Bool {return self._rearLeft != nil}
  /// Clears the value of `rearLeft`. Subsequent reads from it will return its default value.
  mutating func clearRearLeft() {self._rearLeft = nil}

  var rearLeftBlind: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _rearLeftBlind ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_rearLeftBlind = newValue}
  }
  /// Returns true if `rearLeftBlind` has been explicitly set.
  var hasRearLeftBlind: Bool {return self._rearLeftBlind != nil}
  /// Clears the value of `rearLeftBlind`. Subsequent reads from it will return its default value.
  mutating func clearRearLeftBlind() {self._rearLeftBlind = nil}

  var rearRight: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _rearRight ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_rearRight = newValue}
  }
  /// Returns true if `rearRight` has been explicitly set.
  var hasRearRight: Bool {return self._rearRight != nil}
  /// Clears the value of `rearRight`. Subsequent reads from it will return its default value.
  mutating func clearRearRight() {self._rearRight = nil}

  var rearRightBlind: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _rearRightBlind ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_rearRightBlind = newValue}
  }
  /// Returns true if `rearRightBlind` has been explicitly set.
  var hasRearRightBlind: Bool {return self._rearRightBlind != nil}
  /// Clears the value of `rearRightBlind`. Subsequent reads from it will return its default value.
  mutating func clearRearRightBlind() {self._rearRightBlind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _frontLeft: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _frontRight: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _rearBlind: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _rearLeft: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _rearLeftBlind: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _rearRight: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _rearRightBlind: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

struct Proto_SpeedalertStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var threshold: Int32 = 0

  var alertEndTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SpeedalertStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ZEVPreconditioningStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var departureTime: Int32 = 0

  var type: Proto_ZEVPreconditioningType = .unknownZevPreconditioningCommandType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ZEVPreconditioningStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Proto_ZEVPreconditioningType = .unknownZevPreconditioningCommandType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configure preconditioning
struct Proto_ZEVPreconditioningConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var departureTimeMode: Proto_ZEVPreconditioningConfigure.DepartureTimeMode = .disabled

  var departureTime: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DepartureTimeMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case disabled // = 0
    case singleDeparture // = 1
    case weeklyDeparture // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .disabled
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .disabled
      case 1: self = .singleDeparture
      case 2: self = .weeklyDeparture
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .disabled: return 0
      case .singleDeparture: return 1
      case .weeklyDeparture: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_ZEVPreconditioningConfigure.DepartureTimeMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ZEVPreconditioningConfigure.DepartureTimeMode] = [
    .disabled,
    .singleDeparture,
    .weeklyDeparture,
  ]
}

#endif  // swift(>=4.2)

/// Configure which seats should be preconditioned.
/// Currently, the only available options are to precondition all seats or only the front-left seat
struct Proto_ZEVPreconditioningConfigureSeats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frontLeft: Bool = false

  var frontRight: Bool = false

  var rearLeft: Bool = false

  var rearRight: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configure the charge program
struct Proto_BatteryChargeProgramConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeProgram: Proto_BatteryChargeProgramConfigure.ChargeProgram = .default

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ChargeProgram: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `default` // = 0
    case instant // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .instant
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .instant: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_BatteryChargeProgramConfigure.ChargeProgram: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_BatteryChargeProgramConfigure.ChargeProgram] = [
    .default,
    .instant,
  ]
}

#endif  // swift(>=4.2)

/// Configure the maximum value for the state of charge of the HV battery
struct Proto_BatteryMaxSocConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Values need to be between 50 and 100 and divisible by ten
  var maxSoc: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Select the given charge program and enables the consumer to configure it.
struct Proto_ChargeProgramConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeProgram: Proto_ChargeProgramConfigure.ChargeProgram = .defaultChargeProgram

  /// Values need to be between 50 and 100 and divisible by ten
  /// Maximum value for the state of charge of the HV battery [in %].
  /// Valid value range = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
  var maxSoc: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _maxSoc ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_maxSoc = newValue}
  }
  /// Returns true if `maxSoc` has been explicitly set.
  var hasMaxSoc: Bool {return self._maxSoc != nil}
  /// Clears the value of `maxSoc`. Subsequent reads from it will return its default value.
  mutating func clearMaxSoc() {self._maxSoc = nil}

  /// unlock the plug after charging is finished
  /// Denotes whether the charge cable should be unlocked automatically if the HV battery is fully charged resp. charged til Max. SoC value.
  /// true - unlock automatically, false - do not unlock automatically
  /// can only be used if chargeprogram is set to home or work. Otherwise it will be ignored.
  var autoUnlock: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _autoUnlock ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_autoUnlock = newValue}
  }
  /// Returns true if `autoUnlock` has been explicitly set.
  var hasAutoUnlock: Bool {return self._autoUnlock != nil}
  /// Clears the value of `autoUnlock`. Subsequent reads from it will return its default value.
  mutating func clearAutoUnlock() {self._autoUnlock = nil}

  /// automatically switch between home and work program, based on the location of the car
  /// Denotes whether location based charging should be used.
  /// true - use location based charging, false - do not use location based charging
  /// can only be used if chargeprogram is set to home or work. Otherwise it will be ignored.
  var locationBasedCharging: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _locationBasedCharging ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_locationBasedCharging = newValue}
  }
  /// Returns true if `locationBasedCharging` has been explicitly set.
  var hasLocationBasedCharging: Bool {return self._locationBasedCharging != nil}
  /// Clears the value of `locationBasedCharging`. Subsequent reads from it will return its default value.
  mutating func clearLocationBasedCharging() {self._locationBasedCharging = nil}

  /// enable or disable clocktimer
  var clockTimer: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _clockTimer ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_clockTimer = newValue}
  }
  /// Returns true if `clockTimer` has been explicitly set.
  var hasClockTimer: Bool {return self._clockTimer != nil}
  /// Clears the value of `clockTimer`. Subsequent reads from it will return its default value.
  mutating func clearClockTimer() {self._clockTimer = nil}

  /// enable or disable ecocharging
  var ecoCharging: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _ecoCharging ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_ecoCharging = newValue}
  }
  /// Returns true if `ecoCharging` has been explicitly set.
  var hasEcoCharging: Bool {return self._ecoCharging != nil}
  /// Clears the value of `ecoCharging`. Subsequent reads from it will return its default value.
  mutating func clearEcoCharging() {self._ecoCharging = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ChargeProgram: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case defaultChargeProgram // = 0

    /// Instant charge program should not be used
    /// INSTANT_CHARGE_PROGRAM = 1;
    case homeChargeProgram // = 2
    case workChargeProgram // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .defaultChargeProgram
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .defaultChargeProgram
      case 2: self = .homeChargeProgram
      case 3: self = .workChargeProgram
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .defaultChargeProgram: return 0
      case .homeChargeProgram: return 2
      case .workChargeProgram: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _maxSoc: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _autoUnlock: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _locationBasedCharging: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _clockTimer: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _ecoCharging: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

#if swift(>=4.2)

extension Proto_ChargeProgramConfigure.ChargeProgram: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ChargeProgramConfigure.ChargeProgram] = [
    .defaultChargeProgram,
    .homeChargeProgram,
    .workChargeProgram,
  ]
}

#endif  // swift(>=4.2)

/// This is an experimental command
struct Proto_ChargeControlConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enables/Disables bidrectional charging
  var biChargingEnabled: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _biChargingEnabled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_biChargingEnabled = newValue}
  }
  /// Returns true if `biChargingEnabled` has been explicitly set.
  var hasBiChargingEnabled: Bool {return self._biChargingEnabled != nil}
  /// Clears the value of `biChargingEnabled`. Subsequent reads from it will return its default value.
  mutating func clearBiChargingEnabled() {self._biChargingEnabled = nil}

  /// Sets the charging power in kW with a resolution of 0.1 kW. The value has an offset of -100 kW. So
  /// a value of 0 is equivalent to -100 kW.
  var chargingPower: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _chargingPower ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_chargingPower = newValue}
  }
  /// Returns true if `chargingPower` has been explicitly set.
  var hasChargingPower: Bool {return self._chargingPower != nil}
  /// Clears the value of `chargingPower`. Subsequent reads from it will return its default value.
  mutating func clearChargingPower() {self._chargingPower = nil}

  /// must not be above max_soc
  var minSoc: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _minSoc ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_minSoc = newValue}
  }
  /// Returns true if `minSoc` has been explicitly set.
  var hasMinSoc: Bool {return self._minSoc != nil}
  /// Clears the value of `minSoc`. Subsequent reads from it will return its default value.
  mutating func clearMinSoc() {self._minSoc = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _biChargingEnabled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _chargingPower: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
  fileprivate var _minSoc: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

/// Provide functionality to initiate a charge optimization configuration
struct Proto_ChargeOptConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var weekdayTariff: [Proto_ChargeOptConfigure.Tariff] = []

  var weekendTariff: [Proto_ChargeOptConfigure.Tariff] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Tariff {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rate: Proto_ChargeOptConfigure.Tariff.Rate = .invalidPrice

    /// Time in seconds after 00:00
    var time: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Rate: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case invalidPrice // = 0
      case lowPrice // = 33
      case normalPrice // = 44
      case highPrice // = 66
      case UNRECOGNIZED(Int)

      init() {
        self = .invalidPrice
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .invalidPrice
        case 33: self = .lowPrice
        case 44: self = .normalPrice
        case 66: self = .highPrice
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .invalidPrice: return 0
        case .lowPrice: return 33
        case .normalPrice: return 44
        case .highPrice: return 66
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Proto_ChargeOptConfigure.Tariff.Rate: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ChargeOptConfigure.Tariff.Rate] = [
    .invalidPrice,
    .lowPrice,
    .normalPrice,
    .highPrice,
  ]
}

#endif  // swift(>=4.2)

/// Provide the functionality to start the charge optimization function in the vehicle
struct Proto_ChargeOptStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to stop the charge optimization function in the vehicle
struct Proto_ChargeOptStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Set the temperature points of the vehicle
struct Proto_TemperatureConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var temperaturePoints: [Proto_TemperatureConfigure.TemperaturePoint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TemperaturePoint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var zone: Proto_TemperatureConfigure.TemperaturePoint.Zone = .unknown

    var temperatureInCelsius: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Zone: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// the lowercase versions are for json parsing purposes only. The upper case version should be the preferred
      /// enum values to be used in code.
      /// These definitions need to come before upper case versions
      case unknown // = 0
      case frontLeft // = 1
      case frontRight // = 2
      case frontCenter // = 3
      case rearLeft // = 4
      case rearRight // = 5
      case rearCenter // = 6
      case rear2Left // = 7
      case rear2Right // = 8

      /// PLEASE BE AWARE OF THE FOLLOWING BEFORE ADDING NEW ZONES:
      /// Currently there is a bug in vehicle API, that we need to send the zones in the correct order. Otherwise the request will be rejected.
      /// The order needs to be like the following:
      /// Front before rear before rear2
      /// Left before right - There is no center zone if there are left and right zones in this row
      /// As this is already the order like specified here, this needs to be considered on adding new zones.
      case rear2Center // = 9
      static let unknownZone = unknown
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .frontLeft
        case 2: self = .frontRight
        case 3: self = .frontCenter
        case 4: self = .rearLeft
        case 5: self = .rearRight
        case 6: self = .rearCenter
        case 7: self = .rear2Left
        case 8: self = .rear2Right
        case 9: self = .rear2Center
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .frontLeft: return 1
        case .frontRight: return 2
        case .frontCenter: return 3
        case .rearLeft: return 4
        case .rearRight: return 5
        case .rearCenter: return 6
        case .rear2Left: return 7
        case .rear2Right: return 8
        case .rear2Center: return 9
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Proto_TemperatureConfigure.TemperaturePoint.Zone: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_TemperatureConfigure.TemperaturePoint.Zone] = [
    .unknown,
    .frontLeft,
    .frontRight,
    .frontCenter,
    .rearLeft,
    .rearRight,
    .rearCenter,
    .rear2Left,
    .rear2Right,
    .rear2Center,
  ]
}

#endif  // swift(>=4.2)

/// Set the weekprofile for the weekly departure time settings
struct Proto_WeekProfileConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var weeklySetHu: [Proto_WeekProfileConfigure.WeeklySetHU] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct WeeklySetHU {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var day: Proto_WeekProfileConfigure.WeeklySetHU.Day = .monday

    /// Time in minutes after 00:00
    var time: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Day: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case monday // = 0
      case tuesday // = 1
      case wednesday // = 2
      case thursday // = 3
      case friday // = 4
      case saturday // = 5
      case sunday // = 6
      case UNRECOGNIZED(Int)

      init() {
        self = .monday
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .monday
        case 1: self = .tuesday
        case 2: self = .wednesday
        case 3: self = .thursday
        case 4: self = .friday
        case 5: self = .saturday
        case 6: self = .sunday
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .monday: return 0
        case .tuesday: return 1
        case .wednesday: return 2
        case .thursday: return 3
        case .friday: return 4
        case .saturday: return 5
        case .sunday: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Proto_WeekProfileConfigure.WeeklySetHU.Day: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_WeekProfileConfigure.WeeklySetHU.Day] = [
    .monday,
    .tuesday,
    .wednesday,
    .thursday,
    .friday,
    .saturday,
    .sunday,
  ]
}

#endif  // swift(>=4.2)

/// Set the week profile for the weekly departure time settings version 2
struct Proto_WeekProfileConfigureV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// * The whole list of timeProfiles must always be provided
  var timeProfiles: [Proto_TimeProfile] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_TimeProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///=> only if time profile entry is unchanged, do not provide attribute "id" if new profile entry shall be added
  ///   If a new time profile shall be added: do not provide the ID => ID will be set by MIC / vehicle
  var identifier: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _identifier ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  /// Hour after midnight range [0, 23]
  var hour: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _hour ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_hour = newValue}
  }
  /// Returns true if `hour` has been explicitly set.
  var hasHour: Bool {return self._hour != nil}
  /// Clears the value of `hour`. Subsequent reads from it will return its default value.
  mutating func clearHour() {self._hour = nil}

  /// Minute after full hour range [0, 59]
  var minute: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _minute ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_minute = newValue}
  }
  /// Returns true if `minute` has been explicitly set.
  var hasMinute: Bool {return self._minute != nil}
  /// Clears the value of `minute`. Subsequent reads from it will return its default value.
  mutating func clearMinute() {self._minute = nil}

  /// Days for which the above time should be applied
  var days: [Proto_TimeProfileDay] = []

  /// Whether this profile entry is active or not
  var active: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _active ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_active = newValue}
  }
  /// Returns true if `active` has been explicitly set.
  var hasActive: Bool {return self._active != nil}
  /// Clears the value of `active`. Subsequent reads from it will return its default value.
  mutating func clearActive() {self._active = nil}

  /// If a timeProfile is changed or added the respective applicationId must be provided by the SDK
  ///   11 = Internal Apps
  ///   12 = External Apps
  var applicationIdentifier: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _identifier: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _hour: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _minute: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _active: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Invoke the Remote Vehicle Finder for signalling the vehicle’s position with lights, horn or panic alarm.
struct Proto_SigPosStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value needs to be between 0 and 30. The default is 0.
  /// Only allowed for RAMSES
  var hornRepeat: Int32 = 0

  var hornType: Proto_SigPosStart.HornType = .hornOff

  var lightType: Proto_SigPosStart.LightType = .lightOff

  /// Value needs to be between 0 and 10. It indicates how long the light should be switched on.
  var sigposDuration: Int32 = 0

  var sigposType: Proto_SigPosStart.SigposType = .lightOnly

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Only allowed for RAMSES
  enum HornType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case hornOff // = 0
    case hornLowVolume // = 1
    case hornHighVolume // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .hornOff
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .hornOff
      case 1: self = .hornLowVolume
      case 2: self = .hornHighVolume
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .hornOff: return 0
      case .hornLowVolume: return 1
      case .hornHighVolume: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Only allowed for RAMSES
  enum LightType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case lightOff // = 0
    case dippedHeadLight // = 1
    case warningLight // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .lightOff
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .lightOff
      case 1: self = .dippedHeadLight
      case 2: self = .warningLight
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .lightOff: return 0
      case .dippedHeadLight: return 1
      case .warningLight: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum SigposType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case lightOnly // = 0

    /// Only allowed for RAMSES
    case hornOnly // = 1

    /// Only allowed for RAMSES
    case lightAndHorn // = 2

    /// Only allowed for HERMES
    case panicAlarm // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .lightOnly
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .lightOnly
      case 1: self = .hornOnly
      case 2: self = .lightAndHorn
      case 3: self = .panicAlarm
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .lightOnly: return 0
      case .hornOnly: return 1
      case .lightAndHorn: return 2
      case .panicAlarm: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_SigPosStart.HornType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_SigPosStart.HornType] = [
    .hornOff,
    .hornLowVolume,
    .hornHighVolume,
  ]
}

extension Proto_SigPosStart.LightType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_SigPosStart.LightType] = [
    .lightOff,
    .dippedHeadLight,
    .warningLight,
  ]
}

extension Proto_SigPosStart.SigposType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_SigPosStart.SigposType] = [
    .lightOnly,
    .hornOnly,
    .lightAndHorn,
    .panicAlarm,
  ]
}

#endif  // swift(>=4.2)

/// Confirm the detected parking bump
struct Proto_TheftalarmConfirmDamagedetection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to deselect the parking damage detection sensor
struct Proto_TheftalarmDeselectDamagedetection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to deselect the interior protection sensor
struct Proto_TheftalarmDeselectInterior {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to deselect the tow protection sensor
struct Proto_TheftalarmDeselectTow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to select the parking damage detection sensor
struct Proto_TheftalarmSelectDamagedetection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to select the interior protection sensor
struct Proto_TheftalarmSelectInterior {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to select the tow protection sensor
struct Proto_TheftalarmSelectTow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to trigger an alarm that lasts for "alarm_duration" seconds
struct Proto_TheftalarmStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specify how many seconds the alarm should be switched on
  var alarmDurationInSeconds: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to deactivate an active/ongoing alarm
struct Proto_TheftalarmStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AutomaticValetParkingActivate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bookingID: String = String()

  var driveType: Proto_DriveType = .unknownDriveType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ChargeFlapUnlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ChargeCouplerUnlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ChargingBreakClocktimerConfigureEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: Proto_ChargingBreakClocktimerConfigureEntry.Action = .delete

  var endTimeHour: Int64 = 0

  var endTimeMin: Int64 = 0

  var startTimeHour: Int64 = 0

  var startTimeMin: Int64 = 0

  var timerID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Action: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case delete // = 0
    case activate // = 1
    case deactivate // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .delete
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .delete
      case 1: self = .activate
      case 2: self = .deactivate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .delete: return 0
      case .activate: return 1
      case .deactivate: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_ChargingBreakClocktimerConfigureEntry.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ChargingBreakClocktimerConfigureEntry.Action] = [
    .delete,
    .activate,
    .deactivate,
  ]
}

#endif  // swift(>=4.2)

/// Provide the functionality to configure when charging should start and end
struct Proto_ChargingBreakClocktimerConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargingBreakClocktimers: [Proto_ChargingBreakClocktimerConfigureEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Activates teenage driving mode
struct Proto_TeenageDrivingModeActivate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Deactivates teenage driving mode
struct Proto_TeenageDrivingModeDeactivate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Activates valet driving mode
struct Proto_ValetDrivingModeActivate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Deactivates valet driving mode
struct Proto_ValetDrivingModeDeactivate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_Door: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "unknown_door", aliases: ["UNKNOWN_DOOR"]),
    1: .aliased(proto: "frontleft", aliases: ["FRONT_LEFT"]),
    2: .aliased(proto: "frontright", aliases: ["FRONT_RIGHT"]),
    3: .aliased(proto: "rearleft", aliases: ["REAR_LEFT"]),
    4: .aliased(proto: "rearright", aliases: ["REAR_RIGHT"]),
    5: .aliased(proto: "trunk", aliases: ["TRUNK"]),
    6: .aliased(proto: "fuelflap", aliases: ["FUEL_FLAP"]),
    7: .aliased(proto: "chargeflap", aliases: ["CHARGE_FLAP"]),
    8: .aliased(proto: "chargecoupler", aliases: ["CHARGE_COUPLER"]),
  ]
}

extension Proto_ZEVPreconditioningType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "unknown_zev_preconditioning_command_type", aliases: ["UNKNOWN_ZEV_PRECONDITIONING_COMMAND_TYPE"]),
    1: .aliased(proto: "immediate", aliases: ["IMMEDIATE"]),
    2: .aliased(proto: "departure", aliases: ["DEPARTURE"]),
    3: .aliased(proto: "now", aliases: ["NOW"]),
    4: .aliased(proto: "departureWeekly", aliases: ["DEPARTURE_WEEKLY"]),
  ]
}

extension Proto_TimeProfileDay: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "Mo", aliases: ["MONDAY"]),
    1: .aliased(proto: "Tu", aliases: ["TUESDAY"]),
    2: .aliased(proto: "We", aliases: ["WEDNESDAY"]),
    3: .aliased(proto: "Th", aliases: ["THURSDAY"]),
    4: .aliased(proto: "Fr", aliases: ["FRIDAY"]),
    5: .aliased(proto: "Sa", aliases: ["SATURDAY"]),
    6: .aliased(proto: "Su", aliases: ["SUNDAY"]),
  ]
}

extension Proto_DriveType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DRIVE_TYPE"),
    1: .same(proto: "PICK_UP"),
    2: .same(proto: "DROP_OFF"),
  ]
}

extension Proto_AcknowledgeCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeCommandRequest, rhs: Proto_AcknowledgeCommandRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vin"),
    7: .standard(proto: "request_id"),
    36: .same(proto: "backend"),
    2: .standard(proto: "auxheat_start"),
    3: .standard(proto: "auxheat_stop"),
    4: .standard(proto: "auxheat_configure"),
    5: .standard(proto: "doors_lock"),
    6: .standard(proto: "doors_unlock"),
    9: .standard(proto: "sunroof_open"),
    10: .standard(proto: "sunroof_close"),
    11: .standard(proto: "sunroof_lift"),
    47: .standard(proto: "sunroof_move"),
    12: .standard(proto: "windows_open"),
    13: .standard(proto: "windows_close"),
    43: .standard(proto: "windows_ventilate"),
    44: .standard(proto: "windows_move"),
    19: .standard(proto: "engine_start"),
    20: .standard(proto: "engine_stop"),
    21: .standard(proto: "zev_preconditioning_start"),
    22: .standard(proto: "zev_preconditioning_stop"),
    25: .standard(proto: "zev_precondition_configure"),
    26: .standard(proto: "zev_precondition_configure_seats"),
    23: .standard(proto: "speedalert_start"),
    24: .standard(proto: "speedalert_stop"),
    27: .standard(proto: "battery_charge_program"),
    28: .standard(proto: "battery_max_soc"),
    34: .standard(proto: "charge_program_configure"),
    40: .standard(proto: "charge_control_configure"),
    29: .standard(proto: "charge_opt_configure"),
    30: .standard(proto: "charge_opt_start"),
    31: .standard(proto: "charge_opt_stop"),
    32: .standard(proto: "temperature_configure"),
    33: .standard(proto: "week_profile_configure"),
    41: .standard(proto: "week_profile_configure_v2"),
    35: .standard(proto: "sigpos_start"),
    8: .standard(proto: "theftalarm_confirm_damagedetection"),
    14: .standard(proto: "theftalarm_deselect_damagedetection"),
    15: .standard(proto: "theftalarm_deselect_interior"),
    16: .standard(proto: "theftalarm_deselect_tow"),
    17: .standard(proto: "theftalarm_select_damagedetection"),
    18: .standard(proto: "theftalarm_select_interior"),
    37: .standard(proto: "theftalarm_select_tow"),
    38: .standard(proto: "theftalarm_start"),
    39: .standard(proto: "theftalarm_stop"),
    42: .standard(proto: "automatic_valet_parking_activate"),
    45: .standard(proto: "charge_flap_unlock"),
    46: .standard(proto: "charge_coupler_unlock"),
    48: .standard(proto: "deactivate_vehicle_keys"),
    49: .standard(proto: "activate_vehicle_keys"),
    50: .standard(proto: "charging_break_clocktimer_configure"),
    51: .standard(proto: "teenage_driving_mode_activate"),
    52: .standard(proto: "teenage_driving_mode_deactivate"),
    53: .standard(proto: "valet_driving_mode_activate"),
    54: .standard(proto: "valet_driving_mode_deactivate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vin) }()
      case 2: try {
        var v: Proto_AuxheatStart?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .auxheatStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .auxheatStart(v)}
      }()
      case 3: try {
        var v: Proto_AuxheatStop?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .auxheatStop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .auxheatStop(v)}
      }()
      case 4: try {
        var v: Proto_AuxheatConfigure?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .auxheatConfigure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .auxheatConfigure(v)}
      }()
      case 5: try {
        var v: Proto_DoorsLock?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .doorsLock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .doorsLock(v)}
      }()
      case 6: try {
        var v: Proto_DoorsUnlock?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .doorsUnlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .doorsUnlock(v)}
      }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 8: try {
        var v: Proto_TheftalarmConfirmDamagedetection?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .theftalarmConfirmDamagedetection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .theftalarmConfirmDamagedetection(v)}
      }()
      case 9: try {
        var v: Proto_SunroofOpen?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .sunroofOpen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .sunroofOpen(v)}
      }()
      case 10: try {
        var v: Proto_SunroofClose?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .sunroofClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .sunroofClose(v)}
      }()
      case 11: try {
        var v: Proto_SunroofLift?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .sunroofLift(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .sunroofLift(v)}
      }()
      case 12: try {
        var v: Proto_WindowsOpen?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .windowsOpen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .windowsOpen(v)}
      }()
      case 13: try {
        var v: Proto_WindowsClose?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .windowsClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .windowsClose(v)}
      }()
      case 14: try {
        var v: Proto_TheftalarmDeselectDamagedetection?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .theftalarmDeselectDamagedetection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .theftalarmDeselectDamagedetection(v)}
      }()
      case 15: try {
        var v: Proto_TheftalarmDeselectInterior?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .theftalarmDeselectInterior(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .theftalarmDeselectInterior(v)}
      }()
      case 16: try {
        var v: Proto_TheftalarmDeselectTow?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .theftalarmDeselectTow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .theftalarmDeselectTow(v)}
      }()
      case 17: try {
        var v: Proto_TheftalarmSelectDamagedetection?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .theftalarmSelectDamagedetection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .theftalarmSelectDamagedetection(v)}
      }()
      case 18: try {
        var v: Proto_TheftalarmSelectInterior?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .theftalarmSelectInterior(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .theftalarmSelectInterior(v)}
      }()
      case 19: try {
        var v: Proto_EngineStart?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .engineStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .engineStart(v)}
      }()
      case 20: try {
        var v: Proto_EngineStop?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .engineStop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .engineStop(v)}
      }()
      case 21: try {
        var v: Proto_ZEVPreconditioningStart?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .zevPreconditioningStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .zevPreconditioningStart(v)}
      }()
      case 22: try {
        var v: Proto_ZEVPreconditioningStop?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .zevPreconditioningStop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .zevPreconditioningStop(v)}
      }()
      case 23: try {
        var v: Proto_SpeedalertStart?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .speedalertStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .speedalertStart(v)}
      }()
      case 24: try {
        var v: Proto_SpeedalertStop?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .speedalertStop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .speedalertStop(v)}
      }()
      case 25: try {
        var v: Proto_ZEVPreconditioningConfigure?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .zevPreconditionConfigure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .zevPreconditionConfigure(v)}
      }()
      case 26: try {
        var v: Proto_ZEVPreconditioningConfigureSeats?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .zevPreconditionConfigureSeats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .zevPreconditionConfigureSeats(v)}
      }()
      case 27: try {
        var v: Proto_BatteryChargeProgramConfigure?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .batteryChargeProgram(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .batteryChargeProgram(v)}
      }()
      case 28: try {
        var v: Proto_BatteryMaxSocConfigure?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .batteryMaxSoc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .batteryMaxSoc(v)}
      }()
      case 29: try {
        var v: Proto_ChargeOptConfigure?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .chargeOptConfigure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .chargeOptConfigure(v)}
      }()
      case 30: try {
        var v: Proto_ChargeOptStart?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .chargeOptStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .chargeOptStart(v)}
      }()
      case 31: try {
        var v: Proto_ChargeOptStop?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .chargeOptStop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .chargeOptStop(v)}
      }()
      case 32: try {
        var v: Proto_TemperatureConfigure?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .temperatureConfigure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .temperatureConfigure(v)}
      }()
      case 33: try {
        var v: Proto_WeekProfileConfigure?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .weekProfileConfigure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .weekProfileConfigure(v)}
      }()
      case 34: try {
        var v: Proto_ChargeProgramConfigure?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .chargeProgramConfigure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .chargeProgramConfigure(v)}
      }()
      case 35: try {
        var v: Proto_SigPosStart?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .sigposStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .sigposStart(v)}
      }()
      case 36: try { try decoder.decodeSingularEnumField(value: &self.backend) }()
      case 37: try {
        var v: Proto_TheftalarmSelectTow?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .theftalarmSelectTow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .theftalarmSelectTow(v)}
      }()
      case 38: try {
        var v: Proto_TheftalarmStart?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .theftalarmStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .theftalarmStart(v)}
      }()
      case 39: try {
        var v: Proto_TheftalarmStop?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .theftalarmStop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .theftalarmStop(v)}
      }()
      case 40: try {
        var v: Proto_ChargeControlConfigure?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .chargeControlConfigure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .chargeControlConfigure(v)}
      }()
      case 41: try {
        var v: Proto_WeekProfileConfigureV2?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .weekProfileConfigureV2(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .weekProfileConfigureV2(v)}
      }()
      case 42: try {
        var v: Proto_AutomaticValetParkingActivate?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .automaticValetParkingActivate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .automaticValetParkingActivate(v)}
      }()
      case 43: try {
        var v: Proto_WindowsVentilate?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .windowsVentilate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .windowsVentilate(v)}
      }()
      case 44: try {
        var v: Proto_WindowsMove?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .windowsMove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .windowsMove(v)}
      }()
      case 45: try {
        var v: Proto_ChargeFlapUnlock?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .chargeFlapUnlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .chargeFlapUnlock(v)}
      }()
      case 46: try {
        var v: Proto_ChargeCouplerUnlock?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .chargeCouplerUnlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .chargeCouplerUnlock(v)}
      }()
      case 47: try {
        var v: Proto_SunroofMove?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .sunroofMove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .sunroofMove(v)}
      }()
      case 48: try {
        var v: Proto_DeactivateVehicleKeys?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .deactivateVehicleKeys(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .deactivateVehicleKeys(v)}
      }()
      case 49: try {
        var v: Proto_ActivateVehicleKeys?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .activateVehicleKeys(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .activateVehicleKeys(v)}
      }()
      case 50: try {
        var v: Proto_ChargingBreakClocktimerConfigure?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .chargingBreakClocktimerConfigure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .chargingBreakClocktimerConfigure(v)}
      }()
      case 51: try {
        var v: Proto_TeenageDrivingModeActivate?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .teenageDrivingModeActivate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .teenageDrivingModeActivate(v)}
      }()
      case 52: try {
        var v: Proto_TeenageDrivingModeDeactivate?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .teenageDrivingModeDeactivate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .teenageDrivingModeDeactivate(v)}
      }()
      case 53: try {
        var v: Proto_ValetDrivingModeActivate?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .valetDrivingModeActivate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .valetDrivingModeActivate(v)}
      }()
      case 54: try {
        var v: Proto_ValetDrivingModeDeactivate?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .valetDrivingModeDeactivate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .valetDrivingModeDeactivate(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vin.isEmpty {
      try visitor.visitSingularStringField(value: self.vin, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.command {
    case .auxheatStart?: try {
      guard case .auxheatStart(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .auxheatStop?: try {
      guard case .auxheatStop(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .auxheatConfigure?: try {
      guard case .auxheatConfigure(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .doorsLock?: try {
      guard case .doorsLock(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .doorsUnlock?: try {
      guard case .doorsUnlock(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    default: break
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 7)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.command {
    case .theftalarmConfirmDamagedetection?: try {
      guard case .theftalarmConfirmDamagedetection(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .sunroofOpen?: try {
      guard case .sunroofOpen(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .sunroofClose?: try {
      guard case .sunroofClose(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .sunroofLift?: try {
      guard case .sunroofLift(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .windowsOpen?: try {
      guard case .windowsOpen(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .windowsClose?: try {
      guard case .windowsClose(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .theftalarmDeselectDamagedetection?: try {
      guard case .theftalarmDeselectDamagedetection(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .theftalarmDeselectInterior?: try {
      guard case .theftalarmDeselectInterior(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .theftalarmDeselectTow?: try {
      guard case .theftalarmDeselectTow(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .theftalarmSelectDamagedetection?: try {
      guard case .theftalarmSelectDamagedetection(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .theftalarmSelectInterior?: try {
      guard case .theftalarmSelectInterior(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .engineStart?: try {
      guard case .engineStart(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .engineStop?: try {
      guard case .engineStop(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .zevPreconditioningStart?: try {
      guard case .zevPreconditioningStart(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .zevPreconditioningStop?: try {
      guard case .zevPreconditioningStop(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .speedalertStart?: try {
      guard case .speedalertStart(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .speedalertStop?: try {
      guard case .speedalertStop(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .zevPreconditionConfigure?: try {
      guard case .zevPreconditionConfigure(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .zevPreconditionConfigureSeats?: try {
      guard case .zevPreconditionConfigureSeats(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .batteryChargeProgram?: try {
      guard case .batteryChargeProgram(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .batteryMaxSoc?: try {
      guard case .batteryMaxSoc(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .chargeOptConfigure?: try {
      guard case .chargeOptConfigure(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .chargeOptStart?: try {
      guard case .chargeOptStart(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .chargeOptStop?: try {
      guard case .chargeOptStop(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .temperatureConfigure?: try {
      guard case .temperatureConfigure(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .weekProfileConfigure?: try {
      guard case .weekProfileConfigure(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .chargeProgramConfigure?: try {
      guard case .chargeProgramConfigure(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .sigposStart?: try {
      guard case .sigposStart(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    default: break
    }
    if self.backend != .vva {
      try visitor.visitSingularEnumField(value: self.backend, fieldNumber: 36)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.command {
    case .theftalarmSelectTow?: try {
      guard case .theftalarmSelectTow(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .theftalarmStart?: try {
      guard case .theftalarmStart(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .theftalarmStop?: try {
      guard case .theftalarmStop(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .chargeControlConfigure?: try {
      guard case .chargeControlConfigure(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .weekProfileConfigureV2?: try {
      guard case .weekProfileConfigureV2(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .automaticValetParkingActivate?: try {
      guard case .automaticValetParkingActivate(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .windowsVentilate?: try {
      guard case .windowsVentilate(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .windowsMove?: try {
      guard case .windowsMove(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .chargeFlapUnlock?: try {
      guard case .chargeFlapUnlock(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .chargeCouplerUnlock?: try {
      guard case .chargeCouplerUnlock(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .sunroofMove?: try {
      guard case .sunroofMove(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .deactivateVehicleKeys?: try {
      guard case .deactivateVehicleKeys(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .activateVehicleKeys?: try {
      guard case .activateVehicleKeys(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .chargingBreakClocktimerConfigure?: try {
      guard case .chargingBreakClocktimerConfigure(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .teenageDrivingModeActivate?: try {
      guard case .teenageDrivingModeActivate(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .teenageDrivingModeDeactivate?: try {
      guard case .teenageDrivingModeDeactivate(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .valetDrivingModeActivate?: try {
      guard case .valetDrivingModeActivate(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .valetDrivingModeDeactivate?: try {
      guard case .valetDrivingModeDeactivate(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CommandRequest, rhs: Proto_CommandRequest) -> Bool {
    if lhs.vin != rhs.vin {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.backend != rhs.backend {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CommandRequest.Backend: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VVA"),
    1: .same(proto: "VehicleAPI"),
  ]
}

extension Proto_DeactivateVehicleKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeactivateVehicleKeys"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
    2: .standard(proto: "expiration_unix"),
    3: .standard(proto: "expiration_seconds"),
    4: .standard(proto: "expiration_milliseconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expirationUnix) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.expirationSeconds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.expirationMilliseconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    if self.expirationUnix != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationUnix, fieldNumber: 2)
    }
    if !self.expirationSeconds.isEmpty {
      try visitor.visitSingularStringField(value: self.expirationSeconds, fieldNumber: 3)
    }
    if !self.expirationMilliseconds.isEmpty {
      try visitor.visitSingularStringField(value: self.expirationMilliseconds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeactivateVehicleKeys, rhs: Proto_DeactivateVehicleKeys) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.expirationUnix != rhs.expirationUnix {return false}
    if lhs.expirationSeconds != rhs.expirationSeconds {return false}
    if lhs.expirationMilliseconds != rhs.expirationMilliseconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ActivateVehicleKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivateVehicleKeys"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
    2: .standard(proto: "expiration_unix"),
    3: .standard(proto: "expiration_seconds"),
    4: .standard(proto: "expiration_milliseconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expirationUnix) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.expirationSeconds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.expirationMilliseconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    if self.expirationUnix != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationUnix, fieldNumber: 2)
    }
    if !self.expirationSeconds.isEmpty {
      try visitor.visitSingularStringField(value: self.expirationSeconds, fieldNumber: 3)
    }
    if !self.expirationMilliseconds.isEmpty {
      try visitor.visitSingularStringField(value: self.expirationMilliseconds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ActivateVehicleKeys, rhs: Proto_ActivateVehicleKeys) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.expirationUnix != rhs.expirationUnix {return false}
    if lhs.expirationSeconds != rhs.expirationSeconds {return false}
    if lhs.expirationMilliseconds != rhs.expirationMilliseconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuxheatStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuxheatStart"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AuxheatStart, rhs: Proto_AuxheatStart) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuxheatStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuxheatStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AuxheatStop, rhs: Proto_AuxheatStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuxheatConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuxheatConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "time_selection", json: "auxheattimeselection"),
    2: .unique(proto: "time_1", json: "auxheattime1"),
    3: .unique(proto: "time_2", json: "auxheattime2"),
    4: .unique(proto: "time_3", json: "auxheattime3"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.timeSelection) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.time1) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.time2) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.time3) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeSelection != .noSelection {
      try visitor.visitSingularEnumField(value: self.timeSelection, fieldNumber: 1)
    }
    if self.time1 != 0 {
      try visitor.visitSingularInt32Field(value: self.time1, fieldNumber: 2)
    }
    if self.time2 != 0 {
      try visitor.visitSingularInt32Field(value: self.time2, fieldNumber: 3)
    }
    if self.time3 != 0 {
      try visitor.visitSingularInt32Field(value: self.time3, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AuxheatConfigure, rhs: Proto_AuxheatConfigure) -> Bool {
    if lhs.timeSelection != rhs.timeSelection {return false}
    if lhs.time1 != rhs.time1 {return false}
    if lhs.time2 != rhs.time2 {return false}
    if lhs.time3 != rhs.time3 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuxheatConfigure.Selection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_SELECTION"),
    1: .same(proto: "TIME_1"),
    2: .same(proto: "TIME_2"),
    3: .same(proto: "TIME_3"),
  ]
}

extension Proto_DoorsLock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoorsLock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "doors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.doors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.doors.isEmpty {
      try visitor.visitPackedEnumField(value: self.doors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DoorsLock, rhs: Proto_DoorsLock) -> Bool {
    if lhs.doors != rhs.doors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DoorsUnlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoorsUnlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
    2: .same(proto: "doors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.doors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    if !self.doors.isEmpty {
      try visitor.visitPackedEnumField(value: self.doors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DoorsUnlock, rhs: Proto_DoorsUnlock) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.doors != rhs.doors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_EngineStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EngineStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_EngineStart, rhs: Proto_EngineStart) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_EngineStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EngineStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_EngineStop, rhs: Proto_EngineStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SunroofOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SunroofOpen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SunroofOpen, rhs: Proto_SunroofOpen) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SunroofClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SunroofClose"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SunroofClose, rhs: Proto_SunroofClose) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SunroofLift: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SunroofLift"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SunroofLift, rhs: Proto_SunroofLift) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SunroofMove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SunroofMove"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
    2: .same(proto: "sunroof"),
    3: .unique(proto: "sunroof_blind_front", json: "sunroofblindfront"),
    4: .unique(proto: "sunroof_blind_rear", json: "sunroofblindrear"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sunroof) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sunroofBlindFront) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._sunroofBlindRear) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    if let v = self._sunroof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._sunroofBlindFront {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._sunroofBlindRear {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SunroofMove, rhs: Proto_SunroofMove) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs._sunroof != rhs._sunroof {return false}
    if lhs._sunroofBlindFront != rhs._sunroofBlindFront {return false}
    if lhs._sunroofBlindRear != rhs._sunroofBlindRear {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WindowsOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsOpen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WindowsOpen, rhs: Proto_WindowsOpen) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WindowsClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsClose"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WindowsClose, rhs: Proto_WindowsClose) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WindowsVentilate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsVentilate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WindowsVentilate, rhs: Proto_WindowsVentilate) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WindowsMove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsMove"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
    2: .unique(proto: "front_left", json: "windowfrontleft"),
    3: .unique(proto: "front_right", json: "windowfrontright"),
    4: .unique(proto: "rear_blind", json: "windowrearblind"),
    5: .unique(proto: "rear_left", json: "windowrearleft"),
    6: .unique(proto: "rear_left_blind", json: "windowrearleftblind"),
    7: .unique(proto: "rear_right", json: "windowrearright"),
    8: .unique(proto: "rear_right_blind", json: "windowrearrightblind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._frontLeft) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._frontRight) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._rearBlind) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._rearLeft) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._rearLeftBlind) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._rearRight) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._rearRightBlind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    if let v = self._frontLeft {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._frontRight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._rearBlind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._rearLeft {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._rearLeftBlind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._rearRight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._rearRightBlind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WindowsMove, rhs: Proto_WindowsMove) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs._frontLeft != rhs._frontLeft {return false}
    if lhs._frontRight != rhs._frontRight {return false}
    if lhs._rearBlind != rhs._rearBlind {return false}
    if lhs._rearLeft != rhs._rearLeft {return false}
    if lhs._rearLeftBlind != rhs._rearLeftBlind {return false}
    if lhs._rearRight != rhs._rearRight {return false}
    if lhs._rearRightBlind != rhs._rearRightBlind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SpeedalertStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedalertStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "threshold", json: "speedAlertThreshold"),
    2: .unique(proto: "alert_end_time", json: "speedAlertEndTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.threshold) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.alertEndTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.threshold != 0 {
      try visitor.visitSingularInt32Field(value: self.threshold, fieldNumber: 1)
    }
    if self.alertEndTime != 0 {
      try visitor.visitSingularInt64Field(value: self.alertEndTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SpeedalertStart, rhs: Proto_SpeedalertStart) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs.alertEndTime != rhs.alertEndTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SpeedalertStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedalertStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SpeedalertStop, rhs: Proto_SpeedalertStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ZEVPreconditioningStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZEVPreconditioningStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "departure_time", json: "departuretime"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.departureTime) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.departureTime != 0 {
      try visitor.visitSingularInt32Field(value: self.departureTime, fieldNumber: 1)
    }
    if self.type != .unknownZevPreconditioningCommandType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ZEVPreconditioningStart, rhs: Proto_ZEVPreconditioningStart) -> Bool {
    if lhs.departureTime != rhs.departureTime {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ZEVPreconditioningStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZEVPreconditioningStop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknownZevPreconditioningCommandType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ZEVPreconditioningStop, rhs: Proto_ZEVPreconditioningStop) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ZEVPreconditioningConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZEVPreconditioningConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "departure_time_mode"),
    3: .unique(proto: "departure_time", json: "departuretime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.departureTimeMode) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.departureTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.departureTimeMode != .disabled {
      try visitor.visitSingularEnumField(value: self.departureTimeMode, fieldNumber: 1)
    }
    if self.departureTime != 0 {
      try visitor.visitSingularInt32Field(value: self.departureTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ZEVPreconditioningConfigure, rhs: Proto_ZEVPreconditioningConfigure) -> Bool {
    if lhs.departureTimeMode != rhs.departureTimeMode {return false}
    if lhs.departureTime != rhs.departureTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ZEVPreconditioningConfigure.DepartureTimeMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISABLED"),
    1: .same(proto: "SINGLE_DEPARTURE"),
    2: .same(proto: "WEEKLY_DEPARTURE"),
  ]
}

extension Proto_ZEVPreconditioningConfigureSeats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZEVPreconditioningConfigureSeats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "front_left", json: "precondSeatFrontLeft"),
    2: .unique(proto: "front_right", json: "precondSeatFrontRight"),
    3: .unique(proto: "rear_left", json: "precondSeatRearLeft"),
    4: .unique(proto: "rear_right", json: "precondSeatRearRight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.frontLeft) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.frontRight) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.rearLeft) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.rearRight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frontLeft != false {
      try visitor.visitSingularBoolField(value: self.frontLeft, fieldNumber: 1)
    }
    if self.frontRight != false {
      try visitor.visitSingularBoolField(value: self.frontRight, fieldNumber: 2)
    }
    if self.rearLeft != false {
      try visitor.visitSingularBoolField(value: self.rearLeft, fieldNumber: 3)
    }
    if self.rearRight != false {
      try visitor.visitSingularBoolField(value: self.rearRight, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ZEVPreconditioningConfigureSeats, rhs: Proto_ZEVPreconditioningConfigureSeats) -> Bool {
    if lhs.frontLeft != rhs.frontLeft {return false}
    if lhs.frontRight != rhs.frontRight {return false}
    if lhs.rearLeft != rhs.rearLeft {return false}
    if lhs.rearRight != rhs.rearRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_BatteryChargeProgramConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryChargeProgramConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "charge_program", json: "chargeprogram"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.chargeProgram) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chargeProgram != .default {
      try visitor.visitSingularEnumField(value: self.chargeProgram, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_BatteryChargeProgramConfigure, rhs: Proto_BatteryChargeProgramConfigure) -> Bool {
    if lhs.chargeProgram != rhs.chargeProgram {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_BatteryChargeProgramConfigure.ChargeProgram: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "INSTANT"),
  ]
}

extension Proto_BatteryMaxSocConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryMaxSocConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "max_soc", json: "maxsoc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.maxSoc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxSoc != 0 {
      try visitor.visitSingularInt32Field(value: self.maxSoc, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_BatteryMaxSocConfigure, rhs: Proto_BatteryMaxSocConfigure) -> Bool {
    if lhs.maxSoc != rhs.maxSoc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeProgramConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeProgramConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "charge_program", json: "chargeprogram"),
    2: .unique(proto: "max_soc", json: "maxsoc"),
    3: .unique(proto: "auto_unlock", json: "autounlock"),
    4: .unique(proto: "location_based_charging", json: "locationbasedcharging"),
    6: .unique(proto: "clock_timer", json: "clocktimer"),
    7: .unique(proto: "eco_charging", json: "ecocharging"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.chargeProgram) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maxSoc) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._autoUnlock) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._locationBasedCharging) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._clockTimer) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._ecoCharging) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chargeProgram != .defaultChargeProgram {
      try visitor.visitSingularEnumField(value: self.chargeProgram, fieldNumber: 1)
    }
    if let v = self._maxSoc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._autoUnlock {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._locationBasedCharging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._clockTimer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._ecoCharging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeProgramConfigure, rhs: Proto_ChargeProgramConfigure) -> Bool {
    if lhs.chargeProgram != rhs.chargeProgram {return false}
    if lhs._maxSoc != rhs._maxSoc {return false}
    if lhs._autoUnlock != rhs._autoUnlock {return false}
    if lhs._locationBasedCharging != rhs._locationBasedCharging {return false}
    if lhs._clockTimer != rhs._clockTimer {return false}
    if lhs._ecoCharging != rhs._ecoCharging {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeProgramConfigure.ChargeProgram: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT_CHARGE_PROGRAM"),
    2: .same(proto: "HOME_CHARGE_PROGRAM"),
    3: .same(proto: "WORK_CHARGE_PROGRAM"),
  ]
}

extension Proto_ChargeControlConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeControlConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "bi_charging_enabled", json: "bidichargingenabled"),
    2: .unique(proto: "charging_power", json: "chargingpower"),
    3: .unique(proto: "min_soc", json: "minsoc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._biChargingEnabled) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chargingPower) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minSoc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._biChargingEnabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._chargingPower {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._minSoc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeControlConfigure, rhs: Proto_ChargeControlConfigure) -> Bool {
    if lhs._biChargingEnabled != rhs._biChargingEnabled {return false}
    if lhs._chargingPower != rhs._chargingPower {return false}
    if lhs._minSoc != rhs._minSoc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeOptConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOptConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "weekday_tariff", json: "weekdaytariff"),
    2: .unique(proto: "weekend_tariff", json: "weekendtariff"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.weekdayTariff) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.weekendTariff) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.weekdayTariff.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weekdayTariff, fieldNumber: 1)
    }
    if !self.weekendTariff.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weekendTariff, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeOptConfigure, rhs: Proto_ChargeOptConfigure) -> Bool {
    if lhs.weekdayTariff != rhs.weekdayTariff {return false}
    if lhs.weekendTariff != rhs.weekendTariff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeOptConfigure.Tariff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_ChargeOptConfigure.protoMessageName + ".Tariff"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rate"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.rate) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rate != .invalidPrice {
      try visitor.visitSingularEnumField(value: self.rate, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt32Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeOptConfigure.Tariff, rhs: Proto_ChargeOptConfigure.Tariff) -> Bool {
    if lhs.rate != rhs.rate {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeOptConfigure.Tariff.Rate: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_PRICE"),
    33: .same(proto: "LOW_PRICE"),
    44: .same(proto: "NORMAL_PRICE"),
    66: .same(proto: "HIGH_PRICE"),
  ]
}

extension Proto_ChargeOptStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOptStart"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeOptStart, rhs: Proto_ChargeOptStart) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeOptStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOptStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeOptStop, rhs: Proto_ChargeOptStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TemperatureConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TemperatureConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "temperature_points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.temperaturePoints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.temperaturePoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.temperaturePoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TemperatureConfigure, rhs: Proto_TemperatureConfigure) -> Bool {
    if lhs.temperaturePoints != rhs.temperaturePoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TemperatureConfigure.TemperaturePoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_TemperatureConfigure.protoMessageName + ".TemperaturePoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "zone"),
    3: .unique(proto: "temperature_in_celsius", json: "temp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.temperatureInCelsius) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.zone != .unknown {
      try visitor.visitSingularEnumField(value: self.zone, fieldNumber: 1)
    }
    if self.temperatureInCelsius != 0 {
      try visitor.visitSingularDoubleField(value: self.temperatureInCelsius, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TemperatureConfigure.TemperaturePoint, rhs: Proto_TemperatureConfigure.TemperaturePoint) -> Bool {
    if lhs.zone != rhs.zone {return false}
    if lhs.temperatureInCelsius != rhs.temperatureInCelsius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TemperatureConfigure.TemperaturePoint.Zone: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "unknown", aliases: ["UNKNOWN_ZONE"]),
    1: .aliased(proto: "frontLeft", aliases: ["FRONT_LEFT"]),
    2: .aliased(proto: "frontRight", aliases: ["FRONT_RIGHT"]),
    3: .aliased(proto: "frontCenter", aliases: ["FRONT_CENTER"]),
    4: .aliased(proto: "rearLeft", aliases: ["REAR_LEFT"]),
    5: .aliased(proto: "rearRight", aliases: ["REAR_RIGHT"]),
    6: .aliased(proto: "rearCenter", aliases: ["REAR_CENTER"]),
    7: .aliased(proto: "rear2Left", aliases: ["REAR_2_LEFT"]),
    8: .aliased(proto: "rear2Right", aliases: ["REAR_2_RIGHT"]),
    9: .aliased(proto: "rear2Center", aliases: ["REAR_2_CENTER"]),
  ]
}

extension Proto_WeekProfileConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeekProfileConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "weekly_set_hu", json: "weeklySetHU"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.weeklySetHu) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.weeklySetHu.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weeklySetHu, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeekProfileConfigure, rhs: Proto_WeekProfileConfigure) -> Bool {
    if lhs.weeklySetHu != rhs.weeklySetHu {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WeekProfileConfigure.WeeklySetHU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_WeekProfileConfigure.protoMessageName + ".WeeklySetHU"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "day"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.day) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.day != .monday {
      try visitor.visitSingularEnumField(value: self.day, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt32Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeekProfileConfigure.WeeklySetHU, rhs: Proto_WeekProfileConfigure.WeeklySetHU) -> Bool {
    if lhs.day != rhs.day {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WeekProfileConfigure.WeeklySetHU.Day: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MONDAY"),
    1: .same(proto: "TUESDAY"),
    2: .same(proto: "WEDNESDAY"),
    3: .same(proto: "THURSDAY"),
    4: .same(proto: "FRIDAY"),
    5: .same(proto: "SATURDAY"),
    6: .same(proto: "SUNDAY"),
  ]
}

extension Proto_WeekProfileConfigureV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeekProfileConfigureV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "time_profiles", json: "timeprofiles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.timeProfiles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timeProfiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timeProfiles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeekProfileConfigureV2, rhs: Proto_WeekProfileConfigureV2) -> Bool {
    if lhs.timeProfiles != rhs.timeProfiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TimeProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeProfile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "identifier", json: "id"),
    2: .same(proto: "hour"),
    3: .unique(proto: "minute", json: "min"),
    4: .unique(proto: "days", json: "day"),
    5: .same(proto: "active"),
    6: .unique(proto: "application_identifier", json: "applicationId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._hour) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minute) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.days) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._active) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.applicationIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._hour {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._minute {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.days.isEmpty {
      try visitor.visitPackedEnumField(value: self.days, fieldNumber: 4)
    }
    if let v = self._active {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.applicationIdentifier != 0 {
      try visitor.visitSingularInt32Field(value: self.applicationIdentifier, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TimeProfile, rhs: Proto_TimeProfile) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._hour != rhs._hour {return false}
    if lhs._minute != rhs._minute {return false}
    if lhs.days != rhs.days {return false}
    if lhs._active != rhs._active {return false}
    if lhs.applicationIdentifier != rhs.applicationIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SigPosStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SigPosStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "horn_repeat"),
    2: .standard(proto: "horn_type"),
    3: .standard(proto: "light_type"),
    4: .standard(proto: "sigpos_duration"),
    5: .standard(proto: "sigpos_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.hornRepeat) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.hornType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.lightType) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.sigposDuration) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.sigposType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hornRepeat != 0 {
      try visitor.visitSingularInt32Field(value: self.hornRepeat, fieldNumber: 1)
    }
    if self.hornType != .hornOff {
      try visitor.visitSingularEnumField(value: self.hornType, fieldNumber: 2)
    }
    if self.lightType != .lightOff {
      try visitor.visitSingularEnumField(value: self.lightType, fieldNumber: 3)
    }
    if self.sigposDuration != 0 {
      try visitor.visitSingularInt32Field(value: self.sigposDuration, fieldNumber: 4)
    }
    if self.sigposType != .lightOnly {
      try visitor.visitSingularEnumField(value: self.sigposType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SigPosStart, rhs: Proto_SigPosStart) -> Bool {
    if lhs.hornRepeat != rhs.hornRepeat {return false}
    if lhs.hornType != rhs.hornType {return false}
    if lhs.lightType != rhs.lightType {return false}
    if lhs.sigposDuration != rhs.sigposDuration {return false}
    if lhs.sigposType != rhs.sigposType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SigPosStart.HornType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HORN_OFF"),
    1: .same(proto: "HORN_LOW_VOLUME"),
    2: .same(proto: "HORN_HIGH_VOLUME"),
  ]
}

extension Proto_SigPosStart.LightType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIGHT_OFF"),
    1: .same(proto: "DIPPED_HEAD_LIGHT"),
    2: .same(proto: "WARNING_LIGHT"),
  ]
}

extension Proto_SigPosStart.SigposType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIGHT_ONLY"),
    1: .same(proto: "HORN_ONLY"),
    2: .same(proto: "LIGHT_AND_HORN"),
    3: .same(proto: "PANIC_ALARM"),
  ]
}

extension Proto_TheftalarmConfirmDamagedetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmConfirmDamagedetection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmConfirmDamagedetection, rhs: Proto_TheftalarmConfirmDamagedetection) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmDeselectDamagedetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmDeselectDamagedetection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmDeselectDamagedetection, rhs: Proto_TheftalarmDeselectDamagedetection) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmDeselectInterior: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmDeselectInterior"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmDeselectInterior, rhs: Proto_TheftalarmDeselectInterior) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmDeselectTow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmDeselectTow"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmDeselectTow, rhs: Proto_TheftalarmDeselectTow) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmSelectDamagedetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmSelectDamagedetection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmSelectDamagedetection, rhs: Proto_TheftalarmSelectDamagedetection) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmSelectInterior: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmSelectInterior"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmSelectInterior, rhs: Proto_TheftalarmSelectInterior) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmSelectTow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmSelectTow"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmSelectTow, rhs: Proto_TheftalarmSelectTow) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "alarm_duration_in_seconds", json: "alarmduration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.alarmDurationInSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alarmDurationInSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.alarmDurationInSeconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmStart, rhs: Proto_TheftalarmStart) -> Bool {
    if lhs.alarmDurationInSeconds != rhs.alarmDurationInSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmStop, rhs: Proto_TheftalarmStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AutomaticValetParkingActivate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutomaticValetParkingActivate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "booking_id"),
    2: .standard(proto: "drive_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bookingID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.driveType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bookingID.isEmpty {
      try visitor.visitSingularStringField(value: self.bookingID, fieldNumber: 1)
    }
    if self.driveType != .unknownDriveType {
      try visitor.visitSingularEnumField(value: self.driveType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AutomaticValetParkingActivate, rhs: Proto_AutomaticValetParkingActivate) -> Bool {
    if lhs.bookingID != rhs.bookingID {return false}
    if lhs.driveType != rhs.driveType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeFlapUnlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeFlapUnlock"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeFlapUnlock, rhs: Proto_ChargeFlapUnlock) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeCouplerUnlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeCouplerUnlock"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeCouplerUnlock, rhs: Proto_ChargeCouplerUnlock) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargingBreakClocktimerConfigureEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargingBreakClocktimerConfigureEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "end_time_hour"),
    3: .standard(proto: "end_time_min"),
    4: .standard(proto: "start_time_hour"),
    5: .standard(proto: "start_time_min"),
    6: .standard(proto: "timer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endTimeHour) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.endTimeMin) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.startTimeHour) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.startTimeMin) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.timerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .delete {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if self.endTimeHour != 0 {
      try visitor.visitSingularInt64Field(value: self.endTimeHour, fieldNumber: 2)
    }
    if self.endTimeMin != 0 {
      try visitor.visitSingularInt64Field(value: self.endTimeMin, fieldNumber: 3)
    }
    if self.startTimeHour != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimeHour, fieldNumber: 4)
    }
    if self.startTimeMin != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimeMin, fieldNumber: 5)
    }
    if self.timerID != 0 {
      try visitor.visitSingularInt64Field(value: self.timerID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargingBreakClocktimerConfigureEntry, rhs: Proto_ChargingBreakClocktimerConfigureEntry) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.endTimeHour != rhs.endTimeHour {return false}
    if lhs.endTimeMin != rhs.endTimeMin {return false}
    if lhs.startTimeHour != rhs.startTimeHour {return false}
    if lhs.startTimeMin != rhs.startTimeMin {return false}
    if lhs.timerID != rhs.timerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargingBreakClocktimerConfigureEntry.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DELETE"),
    1: .same(proto: "ACTIVATE"),
    2: .same(proto: "DEACTIVATE"),
  ]
}

extension Proto_ChargingBreakClocktimerConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargingBreakClocktimerConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "charging_break_clocktimers", json: "chargingbreakclocktimer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chargingBreakClocktimers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chargingBreakClocktimers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chargingBreakClocktimers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargingBreakClocktimerConfigure, rhs: Proto_ChargingBreakClocktimerConfigure) -> Bool {
    if lhs.chargingBreakClocktimers != rhs.chargingBreakClocktimers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TeenageDrivingModeActivate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TeenageDrivingModeActivate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TeenageDrivingModeActivate, rhs: Proto_TeenageDrivingModeActivate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TeenageDrivingModeDeactivate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TeenageDrivingModeDeactivate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TeenageDrivingModeDeactivate, rhs: Proto_TeenageDrivingModeDeactivate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ValetDrivingModeActivate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValetDrivingModeActivate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ValetDrivingModeActivate, rhs: Proto_ValetDrivingModeActivate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ValetDrivingModeDeactivate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValetDrivingModeDeactivate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ValetDrivingModeDeactivate, rhs: Proto_ValetDrivingModeDeactivate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
