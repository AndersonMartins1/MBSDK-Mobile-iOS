// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: client.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// message that is sent from the client
/// Sending direction: App -> Websocket (-> AppTwin)
struct Proto_ClientMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trackingID: String = String()

  var msg: Proto_ClientMessage.OneOf_Msg? = nil

  var unsubscribeRequest: Proto_UnsubscribeRequest {
    get {
      if case .unsubscribeRequest(let v)? = msg {return v}
      return Proto_UnsubscribeRequest()
    }
    set {msg = .unsubscribeRequest(newValue)}
  }

  var commandRequest: Proto_CommandRequest {
    get {
      if case .commandRequest(let v)? = msg {return v}
      return Proto_CommandRequest()
    }
    set {msg = .commandRequest(newValue)}
  }

  var trackingEvent: Proto_TrackingEvent {
    get {
      if case .trackingEvent(let v)? = msg {return v}
      return Proto_TrackingEvent()
    }
    set {msg = .trackingEvent(newValue)}
  }

  var pingInterval: Proto_ConfigurePingInterval {
    get {
      if case .pingInterval(let v)? = msg {return v}
      return Proto_ConfigurePingInterval()
    }
    set {msg = .pingInterval(newValue)}
  }

  var acknowledgeVepRequest: Proto_AcknowledgeVEPRequest {
    get {
      if case .acknowledgeVepRequest(let v)? = msg {return v}
      return Proto_AcknowledgeVEPRequest()
    }
    set {msg = .acknowledgeVepRequest(newValue)}
  }

  var acknowledgeServiceStatusUpdatesByVin: Proto_AcknowledgeServiceStatusUpdatesByVIN {
    get {
      if case .acknowledgeServiceStatusUpdatesByVin(let v)? = msg {return v}
      return Proto_AcknowledgeServiceStatusUpdatesByVIN()
    }
    set {msg = .acknowledgeServiceStatusUpdatesByVin(newValue)}
  }

  var acknowledgeServiceStatusUpdate: Proto_AcknowledgeServiceStatusUpdate {
    get {
      if case .acknowledgeServiceStatusUpdate(let v)? = msg {return v}
      return Proto_AcknowledgeServiceStatusUpdate()
    }
    set {msg = .acknowledgeServiceStatusUpdate(newValue)}
  }

  var acknowledgeUserDataUpdate: Proto_AcknowledgeUserDataUpdate {
    get {
      if case .acknowledgeUserDataUpdate(let v)? = msg {return v}
      return Proto_AcknowledgeUserDataUpdate()
    }
    set {msg = .acknowledgeUserDataUpdate(newValue)}
  }

  var acknowledgeUserPictureUpdate: Proto_AcknowledgeUserPictureUpdate {
    get {
      if case .acknowledgeUserPictureUpdate(let v)? = msg {return v}
      return Proto_AcknowledgeUserPictureUpdate()
    }
    set {msg = .acknowledgeUserPictureUpdate(newValue)}
  }

  var acknowledgeUserPinUpdate: Proto_AcknowledgeUserPINUpdate {
    get {
      if case .acknowledgeUserPinUpdate(let v)? = msg {return v}
      return Proto_AcknowledgeUserPINUpdate()
    }
    set {msg = .acknowledgeUserPinUpdate(newValue)}
  }

  var updateUserJwtRequest: Proto_UpdateUserJWTRequest {
    get {
      if case .updateUserJwtRequest(let v)? = msg {return v}
      return Proto_UpdateUserJWTRequest()
    }
    set {msg = .updateUserJwtRequest(newValue)}
  }

  var acknowledgeUserVehicleAuthChangedUpdate: Proto_AcknowledgeUserVehicleAuthChangedUpdate {
    get {
      if case .acknowledgeUserVehicleAuthChangedUpdate(let v)? = msg {return v}
      return Proto_AcknowledgeUserVehicleAuthChangedUpdate()
    }
    set {msg = .acknowledgeUserVehicleAuthChangedUpdate(newValue)}
  }

  var acknowledgeAbilityToGetVehicleMasterDataFromRestApi: Proto_AcknowledgeAbilityToGetVehicleMasterDataFromRestAPI {
    get {
      if case .acknowledgeAbilityToGetVehicleMasterDataFromRestApi(let v)? = msg {return v}
      return Proto_AcknowledgeAbilityToGetVehicleMasterDataFromRestAPI()
    }
    set {msg = .acknowledgeAbilityToGetVehicleMasterDataFromRestApi(newValue)}
  }

  var acknowledgeVehicleUpdated: Proto_AcknowledgeVehicleUpdated {
    get {
      if case .acknowledgeVehicleUpdated(let v)? = msg {return v}
      return Proto_AcknowledgeVehicleUpdated()
    }
    set {msg = .acknowledgeVehicleUpdated(newValue)}
  }

  var acknowledgePreferredDealerChange: Proto_AcknowledgePreferredDealerChange {
    get {
      if case .acknowledgePreferredDealerChange(let v)? = msg {return v}
      return Proto_AcknowledgePreferredDealerChange()
    }
    set {msg = .acknowledgePreferredDealerChange(newValue)}
  }

  var acknowledgeApptwinCommandStatusUpdateByVin: Proto_AcknowledgeAppTwinCommandStatusUpdatesByVIN {
    get {
      if case .acknowledgeApptwinCommandStatusUpdateByVin(let v)? = msg {return v}
      return Proto_AcknowledgeAppTwinCommandStatusUpdatesByVIN()
    }
    set {msg = .acknowledgeApptwinCommandStatusUpdateByVin(newValue)}
  }

  var logout: Proto_Logout {
    get {
      if case .logout(let v)? = msg {return v}
      return Proto_Logout()
    }
    set {msg = .logout(newValue)}
  }

  var apptwinPendingCommandsResponse: Proto_AppTwinPendingCommandsResponse {
    get {
      if case .apptwinPendingCommandsResponse(let v)? = msg {return v}
      return Proto_AppTwinPendingCommandsResponse()
    }
    set {msg = .apptwinPendingCommandsResponse(newValue)}
  }

  var acknowledgeVepUpdatesByVin: Proto_AcknowledgeVEPUpdatesByVIN {
    get {
      if case .acknowledgeVepUpdatesByVin(let v)? = msg {return v}
      return Proto_AcknowledgeVEPUpdatesByVIN()
    }
    set {msg = .acknowledgeVepUpdatesByVin(newValue)}
  }

  var acknowledgeAssignedVehicles: Proto_AcknowledgeAssignedVehicles {
    get {
      if case .acknowledgeAssignedVehicles(let v)? = msg {return v}
      return Proto_AcknowledgeAssignedVehicles()
    }
    set {msg = .acknowledgeAssignedVehicles(newValue)}
  }

  var acknowledgePersPinStatusChange: Proto_AcknowledgePersPinStatusChangeUpdate {
    get {
      if case .acknowledgePersPinStatusChange(let v)? = msg {return v}
      return Proto_AcknowledgePersPinStatusChangeUpdate()
    }
    set {msg = .acknowledgePersPinStatusChange(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable {
    case unsubscribeRequest(Proto_UnsubscribeRequest)
    case commandRequest(Proto_CommandRequest)
    case trackingEvent(Proto_TrackingEvent)
    case pingInterval(Proto_ConfigurePingInterval)
    case acknowledgeVepRequest(Proto_AcknowledgeVEPRequest)
    case acknowledgeServiceStatusUpdatesByVin(Proto_AcknowledgeServiceStatusUpdatesByVIN)
    case acknowledgeServiceStatusUpdate(Proto_AcknowledgeServiceStatusUpdate)
    case acknowledgeUserDataUpdate(Proto_AcknowledgeUserDataUpdate)
    case acknowledgeUserPictureUpdate(Proto_AcknowledgeUserPictureUpdate)
    case acknowledgeUserPinUpdate(Proto_AcknowledgeUserPINUpdate)
    case updateUserJwtRequest(Proto_UpdateUserJWTRequest)
    case acknowledgeUserVehicleAuthChangedUpdate(Proto_AcknowledgeUserVehicleAuthChangedUpdate)
    case acknowledgeAbilityToGetVehicleMasterDataFromRestApi(Proto_AcknowledgeAbilityToGetVehicleMasterDataFromRestAPI)
    case acknowledgeVehicleUpdated(Proto_AcknowledgeVehicleUpdated)
    case acknowledgePreferredDealerChange(Proto_AcknowledgePreferredDealerChange)
    case acknowledgeApptwinCommandStatusUpdateByVin(Proto_AcknowledgeAppTwinCommandStatusUpdatesByVIN)
    case logout(Proto_Logout)
    case apptwinPendingCommandsResponse(Proto_AppTwinPendingCommandsResponse)
    case acknowledgeVepUpdatesByVin(Proto_AcknowledgeVEPUpdatesByVIN)
    case acknowledgeAssignedVehicles(Proto_AcknowledgeAssignedVehicles)
    case acknowledgePersPinStatusChange(Proto_AcknowledgePersPinStatusChangeUpdate)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_ClientMessage.OneOf_Msg, rhs: Proto_ClientMessage.OneOf_Msg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.unsubscribeRequest, .unsubscribeRequest): return {
        guard case .unsubscribeRequest(let l) = lhs, case .unsubscribeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commandRequest, .commandRequest): return {
        guard case .commandRequest(let l) = lhs, case .commandRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trackingEvent, .trackingEvent): return {
        guard case .trackingEvent(let l) = lhs, case .trackingEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pingInterval, .pingInterval): return {
        guard case .pingInterval(let l) = lhs, case .pingInterval(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgeVepRequest, .acknowledgeVepRequest): return {
        guard case .acknowledgeVepRequest(let l) = lhs, case .acknowledgeVepRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgeServiceStatusUpdatesByVin, .acknowledgeServiceStatusUpdatesByVin): return {
        guard case .acknowledgeServiceStatusUpdatesByVin(let l) = lhs, case .acknowledgeServiceStatusUpdatesByVin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgeServiceStatusUpdate, .acknowledgeServiceStatusUpdate): return {
        guard case .acknowledgeServiceStatusUpdate(let l) = lhs, case .acknowledgeServiceStatusUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgeUserDataUpdate, .acknowledgeUserDataUpdate): return {
        guard case .acknowledgeUserDataUpdate(let l) = lhs, case .acknowledgeUserDataUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgeUserPictureUpdate, .acknowledgeUserPictureUpdate): return {
        guard case .acknowledgeUserPictureUpdate(let l) = lhs, case .acknowledgeUserPictureUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgeUserPinUpdate, .acknowledgeUserPinUpdate): return {
        guard case .acknowledgeUserPinUpdate(let l) = lhs, case .acknowledgeUserPinUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateUserJwtRequest, .updateUserJwtRequest): return {
        guard case .updateUserJwtRequest(let l) = lhs, case .updateUserJwtRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgeUserVehicleAuthChangedUpdate, .acknowledgeUserVehicleAuthChangedUpdate): return {
        guard case .acknowledgeUserVehicleAuthChangedUpdate(let l) = lhs, case .acknowledgeUserVehicleAuthChangedUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgeAbilityToGetVehicleMasterDataFromRestApi, .acknowledgeAbilityToGetVehicleMasterDataFromRestApi): return {
        guard case .acknowledgeAbilityToGetVehicleMasterDataFromRestApi(let l) = lhs, case .acknowledgeAbilityToGetVehicleMasterDataFromRestApi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgeVehicleUpdated, .acknowledgeVehicleUpdated): return {
        guard case .acknowledgeVehicleUpdated(let l) = lhs, case .acknowledgeVehicleUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgePreferredDealerChange, .acknowledgePreferredDealerChange): return {
        guard case .acknowledgePreferredDealerChange(let l) = lhs, case .acknowledgePreferredDealerChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgeApptwinCommandStatusUpdateByVin, .acknowledgeApptwinCommandStatusUpdateByVin): return {
        guard case .acknowledgeApptwinCommandStatusUpdateByVin(let l) = lhs, case .acknowledgeApptwinCommandStatusUpdateByVin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logout, .logout): return {
        guard case .logout(let l) = lhs, case .logout(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.apptwinPendingCommandsResponse, .apptwinPendingCommandsResponse): return {
        guard case .apptwinPendingCommandsResponse(let l) = lhs, case .apptwinPendingCommandsResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgeVepUpdatesByVin, .acknowledgeVepUpdatesByVin): return {
        guard case .acknowledgeVepUpdatesByVin(let l) = lhs, case .acknowledgeVepUpdatesByVin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgeAssignedVehicles, .acknowledgeAssignedVehicles): return {
        guard case .acknowledgeAssignedVehicles(let l) = lhs, case .acknowledgeAssignedVehicles(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acknowledgePersPinStatusChange, .acknowledgePersPinStatusChange): return {
        guard case .acknowledgePersPinStatusChange(let l) = lhs, case .acknowledgePersPinStatusChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Message to send from the app right before logging out of keycloak
/// Stops the corresponding AppTwin actor and shuts it down and
/// stops the websocket actor (but does not shut it down. This automatically happens, when the websocket connection is terminated)
struct Proto_Logout {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_ClientMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "tracking_id"),
    2: .same(proto: "unsubscribeRequest"),
    3: .same(proto: "commandRequest"),
    4: .standard(proto: "tracking_event"),
    6: .standard(proto: "ping_interval"),
    7: .standard(proto: "acknowledge_vep_request"),
    9: .standard(proto: "acknowledge_service_status_updates_by_vin"),
    13: .standard(proto: "acknowledge_service_status_update"),
    10: .standard(proto: "acknowledge_user_data_update"),
    11: .standard(proto: "acknowledge_user_picture_update"),
    12: .standard(proto: "acknowledge_user_pin_update"),
    14: .standard(proto: "update_user_jwt_request"),
    15: .standard(proto: "acknowledge_user_vehicle_auth_changed_update"),
    16: .standard(proto: "acknowledge_ability_to_get_vehicle_master_data_from_rest_api"),
    17: .standard(proto: "acknowledge_vehicle_updated"),
    18: .standard(proto: "acknowledge_preferred_dealer_change"),
    19: .standard(proto: "acknowledge_apptwin_command_status_update_by_vin"),
    20: .same(proto: "logout"),
    21: .standard(proto: "apptwin_pending_commands_response"),
    22: .standard(proto: "acknowledge_vep_updates_by_vin"),
    23: .standard(proto: "acknowledge_assigned_vehicles"),
    24: .standard(proto: "acknowledge_pers_pin_status_change"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Proto_UnsubscribeRequest?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .unsubscribeRequest(v)}
      }()
      case 3: try {
        var v: Proto_CommandRequest?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .commandRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .commandRequest(v)}
      }()
      case 4: try {
        var v: Proto_TrackingEvent?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .trackingEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .trackingEvent(v)}
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 6: try {
        var v: Proto_ConfigurePingInterval?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .pingInterval(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .pingInterval(v)}
      }()
      case 7: try {
        var v: Proto_AcknowledgeVEPRequest?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgeVepRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgeVepRequest(v)}
      }()
      case 9: try {
        var v: Proto_AcknowledgeServiceStatusUpdatesByVIN?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgeServiceStatusUpdatesByVin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgeServiceStatusUpdatesByVin(v)}
      }()
      case 10: try {
        var v: Proto_AcknowledgeUserDataUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgeUserDataUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgeUserDataUpdate(v)}
      }()
      case 11: try {
        var v: Proto_AcknowledgeUserPictureUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgeUserPictureUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgeUserPictureUpdate(v)}
      }()
      case 12: try {
        var v: Proto_AcknowledgeUserPINUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgeUserPinUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgeUserPinUpdate(v)}
      }()
      case 13: try {
        var v: Proto_AcknowledgeServiceStatusUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgeServiceStatusUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgeServiceStatusUpdate(v)}
      }()
      case 14: try {
        var v: Proto_UpdateUserJWTRequest?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .updateUserJwtRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .updateUserJwtRequest(v)}
      }()
      case 15: try {
        var v: Proto_AcknowledgeUserVehicleAuthChangedUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgeUserVehicleAuthChangedUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgeUserVehicleAuthChangedUpdate(v)}
      }()
      case 16: try {
        var v: Proto_AcknowledgeAbilityToGetVehicleMasterDataFromRestAPI?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgeAbilityToGetVehicleMasterDataFromRestApi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgeAbilityToGetVehicleMasterDataFromRestApi(v)}
      }()
      case 17: try {
        var v: Proto_AcknowledgeVehicleUpdated?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgeVehicleUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgeVehicleUpdated(v)}
      }()
      case 18: try {
        var v: Proto_AcknowledgePreferredDealerChange?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgePreferredDealerChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgePreferredDealerChange(v)}
      }()
      case 19: try {
        var v: Proto_AcknowledgeAppTwinCommandStatusUpdatesByVIN?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgeApptwinCommandStatusUpdateByVin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgeApptwinCommandStatusUpdateByVin(v)}
      }()
      case 20: try {
        var v: Proto_Logout?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .logout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .logout(v)}
      }()
      case 21: try {
        var v: Proto_AppTwinPendingCommandsResponse?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .apptwinPendingCommandsResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .apptwinPendingCommandsResponse(v)}
      }()
      case 22: try {
        var v: Proto_AcknowledgeVEPUpdatesByVIN?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgeVepUpdatesByVin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgeVepUpdatesByVin(v)}
      }()
      case 23: try {
        var v: Proto_AcknowledgeAssignedVehicles?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgeAssignedVehicles(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgeAssignedVehicles(v)}
      }()
      case 24: try {
        var v: Proto_AcknowledgePersPinStatusChangeUpdate?
        if let current = self.msg {
          try decoder.handleConflictingOneOf()
          if case .acknowledgePersPinStatusChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.msg = .acknowledgePersPinStatusChange(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.msg {
    case .unsubscribeRequest?: try {
      guard case .unsubscribeRequest(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .commandRequest?: try {
      guard case .commandRequest(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .trackingEvent?: try {
      guard case .trackingEvent(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    default: break
    }
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 5)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.msg {
    case .pingInterval?: try {
      guard case .pingInterval(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .acknowledgeVepRequest?: try {
      guard case .acknowledgeVepRequest(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .acknowledgeServiceStatusUpdatesByVin?: try {
      guard case .acknowledgeServiceStatusUpdatesByVin(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .acknowledgeUserDataUpdate?: try {
      guard case .acknowledgeUserDataUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .acknowledgeUserPictureUpdate?: try {
      guard case .acknowledgeUserPictureUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .acknowledgeUserPinUpdate?: try {
      guard case .acknowledgeUserPinUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .acknowledgeServiceStatusUpdate?: try {
      guard case .acknowledgeServiceStatusUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .updateUserJwtRequest?: try {
      guard case .updateUserJwtRequest(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .acknowledgeUserVehicleAuthChangedUpdate?: try {
      guard case .acknowledgeUserVehicleAuthChangedUpdate(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .acknowledgeAbilityToGetVehicleMasterDataFromRestApi?: try {
      guard case .acknowledgeAbilityToGetVehicleMasterDataFromRestApi(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .acknowledgeVehicleUpdated?: try {
      guard case .acknowledgeVehicleUpdated(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .acknowledgePreferredDealerChange?: try {
      guard case .acknowledgePreferredDealerChange(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .acknowledgeApptwinCommandStatusUpdateByVin?: try {
      guard case .acknowledgeApptwinCommandStatusUpdateByVin(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .logout?: try {
      guard case .logout(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .apptwinPendingCommandsResponse?: try {
      guard case .apptwinPendingCommandsResponse(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .acknowledgeVepUpdatesByVin?: try {
      guard case .acknowledgeVepUpdatesByVin(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .acknowledgeAssignedVehicles?: try {
      guard case .acknowledgeAssignedVehicles(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .acknowledgePersPinStatusChange?: try {
      guard case .acknowledgePersPinStatusChange(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ClientMessage, rhs: Proto_ClientMessage) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Logout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Logout"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Logout, rhs: Proto_Logout) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
